#!/usr/bin/env python

__doc__ = "generate plots of processes from CSV files which refer to EOS tables (other csv files) as a corner plot at a few reference points. Uses KDEs to make the plots pretty"
__usage__ = "kde_corner_process [--options] samples.csv reference_column column [column column ...]"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import numpy as np

from optparse import OptionParser

### non-standard libraries
from universality import utils
from universality import plot

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__doc__)

parser.add_option('-v', '--verbose', default=False, action='store_true')
parser.add_option('-V', '--Verbose', default=False, action='store_true')

parser.add_option('', '--logcolumn', default=[], type='string', action='append',
    help='convert the values read in for this column to natural log. \
Can be repeated to specify multiple columns. \
DEFAULT=[]')
parser.add_option('', '--column-label', nargs=2, default=[], type='string', action='append',
    help='replace the column name with this label in the corner plot. e.g.: \'xcol $x$\'. \
DEFAULT=[]')
parser.add_option('', '--column-truth', nargs=3, default=[], type='string', action='append',
    help='include this as an injected value for this column at the specified reference value. e.g: \'xcol ${ref_val} ${inj_val}\'. \
DEFAULT=[]')
parser.add_option('', '--truth-color', default=plot.DEFAULT_TRUTH_COLOR, type='string')

parser.add_option('', '--weight-column', default=None, type='string',
    help='if provided, thie numerical values from this column will be used as weights in the KDE')
parser.add_option('', '--weight-column-is-log', default=False, action='store_true',
    help='if supplied, interpret the values in weight_column as log(weight), meaning we exponentiate them before using them in the KDE')

parser.add_option('-r', '--reference-value', default=[], type='float', action='append',
    help='the reference values at which we extract values from the EOS parameters. \
DEFAULT=[]')

parser.add_option('', '--eos-column', default='eos', type='string')
parser.add_option('', '--eos-dir', default='.', type='string')
parser.add_option('', '--eos-basename', default='draw_foo-%d.csv', type='string',
    help='a string into which the EOS number can be substituted when building filenames. \
DEFAULT=draw_foo-%d.csv')

parser.add_option('--color', default=plot.DEFAULT_COLOR1, type='string',
    help='DEFAULT='+plot.DEFAULT_COLOR1)
parser.add_option('--num-points', default=plot.DEFAULT_NUM_POINTS, type='int',
    help='DEFAULT=%d'%plot.DEFAULT_NUM_POINTS)
parser.add_option('', '--bandwidth', nargs=3, default=[], type='string', action='append',
    help='the bandwidths used for each column specified at each reference value. e.g.: "col ${ref_val} ${bandwidth}". \
We assume diagonal covariance matricies in the Gaussian kernel. \
If you do not specify a bandwidth for a column, the default value (%.3f) will be used.'%utils.DEFAULT_BANDWIDTH)
parser.add_option('', '--reflect', default=False, action='store_true',
    help='reflect the points about their boundaries within the KDE')

parser.add_option('--level', default=[], type=float, action='append',
    help='confidence levels for the contour plots. Can be repeated.')
parser.add_option('--hist1D', default=False, action='store_true',
    help='include raw histrograms in 1D marginal panels')
parser.add_option('--include-neff', default=False, action='store_true',
    help='include an estimate of the effective number of samples as a title')
parser.add_option('--no-scatter', default=False, action='store_true')
parser.add_option('--rotate', default=False, action='store_true',
    help='rotate the last 1D histogram')

parser.add_option('--figwidth', default=plot.DEFAULT_FIGWIDTH, type='float')
parser.add_option('--figheight', default=plot.DEFAULT_FIGHEIGHT, type='float')
parser.add_option('-o', '--output-dir', default='.', type='string')
parser.add_option('-t', '--tag', default='', type='string')

opts, args = parser.parse_args()

assert len(opts.reference_value), 'please supply at least one --reference-value\n%s'%__usage__
opts.reference_value.sort()

assert len(args)>2, 'please supply at least 3 input argument\n%s'%__usage__
inpath, reference = args[:2]
columns = args[2:]

if opts.tag:
    opts.tag = "_"+opts.tag

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

if not opts.level:
    opts.level = plot.DEFAULT_LEVELS

opts.verbose |= opts.Verbose

labeldict = dict(opts.column_label)

truthdict = dict((col, {}) for col in columns)
for col, ref, val in opts.column_truth:
    truthdict[col][float(ref)] = float(val)

bandwidthdict = dict((col, {}) for col in columns)
for col, ref, val in opts.bandwidth:
    bandwidthdict[col][float(ref)] = float(val)

#-------------------------------------------------

if opts.verbose:
    print('reading samples from: '+inpath)
data, _ = utils.load(inpath, [opts.eos_column])
data = data[:,0]
N = len(data)

if opts.weight_column!=None:
    if opts.verbose:
        print('reading in non-trivial weights from: '+inpath)
    weights, _ = utils.load(inpath, [opts.weight_column])
    weights = weights.reshape((len(weights)))

    if opts.weight_column_is_log:
        weights = np.exp(weights-np.max(weights))
    weights /= np.sum(weights)

else:
    weights = np.ones(N, dtype='float')/N

#------------------------

if opts.verbose:
    print('extacting data at reference values')
Ncol = len(columns)
Nref = len(opts.reference_value)
ans = np.empty((N, Nref*Ncol), dtype='float')

loadcolumns = [reference]+columns
refind = loadcolumns.index(reference)
for i, eos in enumerate(data):
    path = os.path.join(opts.eos_dir, opts.eos_basename%eos)
    if opts.Verbose:
        print('    '+path)
    d, c = utils.load(path, loadcolumns)

    for j, column in enumerate(c[1:]):
        ans[i,j*Nref:(j+1)*Nref] = np.interp(opts.reference_value, d[:,refind], d[:,loadcolumns.index(column)])

#-----------------------

if opts.verbose:
    print('plotting')

### build labels and take logs as needed
labels = []
truths = []
bandwidths = []
for i, column in enumerate(columns):
    if column in opts.logcolumn:
        labels += ['log('+column+')\n(%s=%.3e)'%(reference, value) for value in opts.reference_value]
        ans[:,i*Nref:(i+1)*Nref] = np.log(ans[:,i*Nref:(i+1)*Nref])
    else:
        labels += [column+'\n(%s=%.3e)'%(reference, value) for value in opts.reference_value]

    truths += [truthdict[column].get(value, None) for value in opts.reference_value]
    bandwidths += [bandwidthdict[column].get(value, utils.DEFAULT_BANDWIDTH) for value in opts.reference_value]

fig = plot.kde_corner(
    ans,
    bandwidths=bandwidths,
    labels=labels,
    truths=truths,
    truth_color=opts.truth_color,
    weights=weights,
    num_points=opts.num_points,
    color=opts.color,
    reflect=opts.reflect,
    verbose=opst.Verbose,
    hist1D=opts.hist1D,
    levels=opts.level,
    scatter=not opts.no_scatter,
    rotate=opts.rotate,
    figwidth=opts.figwidth,
    figheight=opts.figheight,
)

if opts.include_neff:
    fig.suptitle('$N_\mathrm{eff} = %.1f$'%utils.neff(weights))

figname = os.path.join(opts.output_dir, 'kde_corner_process%s.png'%opts.tag)
if opts.verbose:
    print('saving: '+figname)
fig.savefig(figname)
plot.plt.close(fig)
