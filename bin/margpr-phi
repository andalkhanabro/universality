#!/usr/bin/env python

__doc__ = "a script that lets users investigate hyperparameters and different optimization/marginalization techniques"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import gaussianprocess as gp
from universality import hyperparams as hp
from universality import utils
from universality import plot

#-------------------------------------------------

DEFAULT_MIN_PRESSURE = 1e30 ### g/cm^3
DFEAULT_MAX_PRESSURE = 1e38

DEFAULT_MIN_SIGMA = 1.e-4
DEFAULT_MAX_SIGMA = 1.0

DEFAULT_MIN_L = 0.1
DEFAULT_MAX_L = 5.0

DEFAULT_SIGMA_PRIOR = 'log'
DEFAULT_L_PRIOR = 'lin'

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

### required arguments
rgroup = parser.add_argument_group('required arguments')
rgroup.add_argument('eospath', type=str)

### verbosity arguments
vgroup = parser.add_argument_group('verbosity options')
vgroup.add_argument('-v', '--verbose', default=False, action='store_true')

### gaussian process options
ggroup = parser.add_argument_group('Gaussian Process options')
ggroup.add_argument('--pressure-bounds', default=(DEFAULT_MIN_PRESSURE, DFEAULT_MAX_PRESSURE), nargs=2, type=float,
    help='min max values for resample-pressure. Specified in g/cm^3. \
DEFAULT=%.3e %.3e'%(DEFAULT_MIN_PRESSURE, DFEAULT_MAX_PRESSURE))
ggroup.add_argument('--pressure-num', default=gp.DEFAULT_NUM, type=int,
    help='resample to this number of points. \
DEFAULT=%d'%gp.DEFAULT_NUM)
ggroup.add_argument('--poly-degree', default=gp.DEFAULT_POLY_DEGREE, type=int,
    help='DEFAULT=%d'%gp.DEFAULT_POLY_DEGREE)

### workflow options
mgroup = parser.add_argument_group('mcmc options')
mgroup.add_argument('--min-sigma', default=DEFAULT_MIN_SIGMA, type=float,
    help='DEFAULT=%.3f'%DEFAULT_MIN_SIGMA)
mgroup.add_argument('--max-sigma', default=DEFAULT_MAX_SIGMA, type=float,
    help='DEFAULT=%.3e'%DEFAULT_MAX_SIGMA)

mgroup.add_argument('--min-l', default=DEFAULT_MIN_L, type=float,
    help='DEFAULT=%.3f'%DEFAULT_MIN_L)
mgroup.add_argument('--max-l', default=DEFAULT_MAX_L, type=float,
    help='DEFAULT=%.3f'%DEFAULT_MAX_L)

mgroup.add_argument('--min-sigma_obs', default=DEFAULT_MIN_SIGMA, type=float,
    help='DEFAULT=%.3f'%DEFAULT_MIN_SIGMA)
mgroup.add_argument('--max-sigma_obs', default=DEFAULT_MAX_SIGMA, type=float,
    help='DEFAULT=%.3f'%DEFAULT_MAX_SIGMA)

mgroup.add_argument('--num-mcmc', default=hp.DEFAULT_NUM_MCMC, type=int,
    help='the number of samples to draw in mcmc. \
DEFAULT=%d'%hp.DEFAULT_NUM_MCMC)
mgroup.add_argument('--strip-mcmc', default=hp.DEFAULT_NUM_STRIP, type=int,
    help='the number of burn in samples to reject from the mcmc sampler')

mgroup.add_argument('--num-walkers', default=hp.DEFAULT_NUM_WALKERS, type=int,
    help='DEFAULT=%d'%hp.DEFAULT_NUM_WALKERS)

mgroup.add_argument('--l-prior', default=DEFAULT_L_PRIOR, type=str)
mgroup.add_argument('--sigma-prior', default=DEFAULT_SIGMA_PRIOR, type=str)
mgroup.add_argument('--sigma_obs-prior', default=DEFAULT_SIGMA_PRIOR, type=str)

### output options
ogroup = parser.add_argument_group('output options')
ogroup.add_argument('--plot', default=False, action='store_true',
    help='generate plots for each resampled eos for sanity checking purposes')

ogroup.add_argument('-o', '--output-dir', default='.', type=str)
ogroup.add_argument('-t', '--tag', default='', type=str)

args = parser.parse_args()

basename = os.path.basename(args.eospath)[:-4]

if args.tag:
    args.tag = "_"+args.tag

if not os.path.exists(args.output_dir):
    os.makedirs(args.output_dir)

#-------------------------------------------------

if args.verbose:
    print('reading: '+args.eospath)
data, cols = utils.load(args.eospath, ['pressurec2', 'energy_densityc2'])
logp_obs = np.log(data[:,0])
loge_obs = np.log(data[:,1])

### sample logLike to get distribution of hyperparams
if args.verbose:
    print('running MCMC for %d steps with %d walkers to sample hyperparameters'%(args.num_mcmc, args.num_walkers))

#c2 = utils.c**2
#truth = (np.log(args.pressure_bounds[0]/c2)<=logp_obs)*(logp_obs<=np.log(args.pressure_bounds[1]/c2))
truth = np.ones_like(logp_obs, dtype=bool)

mcmc = hp.logLike_mcmc(
    loge_obs[truth],
    logp_obs[truth],
    (args.min_sigma, args.max_sigma),
    (args.min_l, args.max_l),
    (args.min_sigma_obs, args.max_sigma_obs),
    num_samples=args.num_mcmc,
    num_walkers=args.num_walkers,
    l_prior=args.l_prior,
    sigma_prior=args.sigma_prior,
    sigma_obs_prior=args.sigma_obs_prior,
    degree=args.poly_degree,
)
if args.verbose:
    print('discarding %d samples as burn in'%args.strip_mcmc)
mcmc = mcmc[args.strip_mcmc:]

path = "%s/margpr_phi-mcmc-%s%s.csv"%(args.output_dir, basename, args.tag)
if args.verbose:
    print('writing: '+path)
tmp = ','.join('%.9e' for _ in mcmc.dtype.names)
with open(path, 'w') as file_obj:
    print >> file_obj, ','.join(mcmc.dtype.names)
    for sample in mcmc:
        print >> file_obj, tmp%tuple(sample)

if args.plot:
    if args.verbose:
        print('plotting')
    fig = plot.corner(
        np.transpose([mcmc['sigma'], mcmc['l'], mcmc['sigma_obs'], mcmc['logLike']]),
        labels=['$\sigma$', '$l$', '$\sigma_\mathrm{obs}$', '$\log\mathcal{L}$'],
    )
    figname = '%s/margpr_phi-mcmc-%s%s.png'%(args.output_dir, basename, args.tag)
    if args.verbose:
        print('    saving: '+figname)
    fig.savefig(figname)
    plot.plt.close(fig)


### resample eos into a big matrix
### generate all data structures we'll need here
if args.verbose:
    print('resampling %d observations to %d+%d points within [%.3e, %.3e] g/cm^3 '%((len(loge_obs), args.pressure_num, args.pressure_num,)+args.pressure_bounds))
logp_resample = np.linspace(
    np.log(args.pressure_bounds[0]),
    np.log(args.pressure_bounds[1]),
    args.pressure_num,
)
logp_resample -= 2*np.log(utils.c)

### run gpr to resample this eos
truth = (np.min(logp_obs)<=logp_resample)*(logp_resample<=np.max(logp_obs)) ### only keep samples below the max tabulated value
if not np.any(truth):
    raise ValueError, 'no samples found with requested range. Skipping this EOS'
logp_resample = logp_resample[truth]

mean_f, mean_dfdx, cov_f_f, cov_f_dfdx, cov_dfdx_f, cov_dfdx_dfdx = hp.samples2resample_f_dfdx(
    logp_resample,
    loge_obs,
    logp_obs,
    mcmc,
    degree=args.poly_degree,
)

if args.verbose:
    print('computing process for phi')
mean_phi, truth = gp.mean_phi(logp_resample, mean_f, mean_dfdx)
mean_phi = mean_phi[truth] ### prune bad (acausal?) samples from the data set!

cov_phi_phi = gp.cov_phi_phi(
    logp_resample[truth],
    mean_f[truth],
    mean_dfdx[truth],
    cov_f_f[truth,:][:,truth],
    cov_f_dfdx[truth,:][:,truth],
    cov_dfdx_f[truth,:][:,truth],
    cov_dfdx_dfdx[truth,:][:,truth],
)

### save the process for this resample to file
### NOTE: we do not actually record the full covariance matrix between f and df/dx. That's probably not needed, so this is probably ok

# just f
pklpath = os.path.join(args.output_dir, 'margpr_phi-f-%s%s.pkl'%(basename, args.tag))
if args.verbose:
    print('writing process to: '+pklpath)
gp.pkldump(pklpath, 'logpressurec2', 'logenergy_densityc2', logp_resample, mean_f, cov_f_f)

# just df/dx
pklpath = os.path.join(args.output_dir, 'margpr_phi-dfdx-%s%s.pkl'%(basename, args.tag))
if args.verbose:
    print('writing process to: '+pklpath)
gp.pkldump(pklpath, 'logpressurec2', 'dlogenergy_densitydpressure', logp_resample, mean_dfdx, cov_dfdx_dfdx)

# just phi
pklpath = os.path.join(args.output_dir, 'margpr_phi-%s%s.pkl'%(basename, args.tag))
if args.verbose:
    print('writing process to: '+pklpath)
gp.pkldump(pklpath, 'logpressurec2', 'phi', logp_resample[truth], mean_phi, cov_phi_phi)

#--- generate a sanity check plot?
if args.plot:
    figname = pklpath[:-3]+'png'
    if args.verbose:
        print('saving: '+figname)
    fig = plot.big_sanity_check(
        logp_resample[truth],
        mean_f[truth],
        mean_dfdx[truth],
        mean_phi,
        (np.diag(cov_f_f)**0.5)[truth],
        (np.diag(cov_dfdx_dfdx)**0.5)[truth],
        np.diag(cov_phi_phi)**0.5,
        [logp_obs],
        [loge_obs],
    )[0]
    fig.suptitle(os.path.basename(path)[:-4])
    fig.savefig(figname)
    plot.plt.close(fig)
