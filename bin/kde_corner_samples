#!/usr/bin/env python

__doc__ = "a corner plot based on fancy KDEs to make them prettier"
__usage__ = "kde_corner_samples [--options] samples.csv column1 [column2 column3...]"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import numpy as np

from optparse import OptionParser

### non-standard libraries
from universality import utils
from universality import plot

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__doc__)

parser.add_option('-v', '--verbose', default=False, action='store_true')
parser.add_option('-V', '--Verbose', default=False, action='store_true')

parser.add_option('', '--logcolumn', default=[], type='string', action='append',
    help='convert the values read in for this column to natural log. \
Can be repeated to specify multiple columns. \
DEFAULT=[]')
parser.add_option('', '--column-label', nargs=2, default=[], type='string', action='append',
    help='replace the column name with this label in the corner plot. e.g.: \'xcol $x$\'. \
DEFAULT=[]')
parser.add_option('', '--column-truth', nargs=2, default=[], type='string', action='append',
    help='include this as an injected value for this column. e.g: \'xcol 5\'. \
DEFAULT=[]')
parser.add_option('', '--truth-color', default=plot.DEFAULT_TRUTH_COLOR, type='string')

parser.add_option('', '--range', nargs=3, default=[], action='append', type='string',
    help='specify the ranges used in corner.corner (eg.: "--range column minimum maximum"). \
Can specify ranges for multiple columns by repeating this option. \
DEFAULT will use the minimum and maximum observed sample points.')

parser.add_option('--max-num-samples', default=utils.DEFAULT_MAX_NUM_SAMPLES, type='int')
parser.add_option('', '--weight-column', default=None, type='string',
    help='if provided, thie numerical values from this column will be used as weights in the KDE')
parser.add_option('', '--weight-column-is-log', default=False, action='store_true',
    help='if supplied, interpret the values in weight_column as log(weight), meaning we exponentiate them before using them in the KDE')

parser.add_option('', '--whiten', default=False, action='store_true',
    help='if specified, bandwidths will be interpreted as the whitened bandwidths.')

parser.add_option('--reference', default=[], type='string', action='append',
    help='path to a reference CSV that will be plotted on top of the corner plot. Can be repeated to specify multiple reference curves. \
The columns must be the same as those supplied in the input arguments. \
DEFAULT=[]')
parser.add_option('--reference-color', default=None, type='string')

parser.add_option('--color', default=plot.DEFAULT_COLOR1, type='string',
    help='DEFAULT='+plot.DEFAULT_COLOR1)
parser.add_option('--num-points', default=plot.DEFAULT_NUM_POINTS, type='int',
    help='DEFAULT=%d'%plot.DEFAULT_NUM_POINTS)
parser.add_option('', '--bandwidth', nargs=2, default=[], type='string', action='append',
    help='the bandwidths used for each column specified. We assume diagonal covariance matricies in the Gaussian kernel. \
If you do not specify a bandwidth for a column, the default value (%.3f) will be used.'%utils.DEFAULT_BANDWIDTH)
parser.add_option('', '--reflect', default=False, action='store_true',
    help='reflect the points about their boundaries within the KDE')
parser.add_option('', '--prune', default=False, action='store_true',
    help='throw away samples that live outside the specified ranges')

parser.add_option('--level', default=[], type=float, action='append',
    help='confidence level for the contour plots. Can be repeated to specify multiple levels.')
parser.add_option('--hist1D', default=False, action='store_true',
    help='include raw histrograms in 1D marginal panels')
parser.add_option('--include-neff', default=False, action='store_true',
    help='include an estimate of the effective number of samples as a title')
parser.add_option('--no-scatter', default=False, action='store_true')
parser.add_option('--rotate', default=False, action='store_true',
    help='rotate the last 1D histogram')

parser.add_option('--figwidth', default=plot.DEFAULT_FIGWIDTH, type='float')
parser.add_option('--figheight', default=plot.DEFAULT_FIGHEIGHT, type='float')
parser.add_option('-o', '--output-dir', default='.', type='string')
parser.add_option('-t', '--tag', default='', type='string')
parser.add_option('--figtype', default=[], type='string', action='append')
parser.add_option('--dpi', default=plot.DEFAULT_DPI, type='float')

opts, args = parser.parse_args()
assert len(args)>1, 'please supply at least 2 input argument\n%s'%__usage__
inpath = args[0]
columns = args[1:]
Ncol = len(columns)

if opts.tag:
    opts.tag = "_"+opts.tag

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

if not opts.figtype:
    opts.figtype = plot.DEFAULT_FIGTYPES

if not opts.level:
    opts.level = plot.DEFAULT_LEVELS

opts.verbose |= opts.Verbose

rangesdict = dict((column,(float(_min), float(_max))) for column, _min, _max in opts.range)

bandwidthdict = dict((col, float(b)) for col, b in opts.bandwidth)
bandwidths = [bandwidthdict.get(col, utils.DEFAULT_BANDWIDTH) for col in columns]

labeldict = dict(opts.column_label)
labels = [labeldict.get(col, '$'+col+'$') for col in columns]

truthdict = dict((col, float(val)) for col, val in opts.column_truth)
truths = [truthdict.get(col, None) for col in columns]

#-------------------------------------------------

### plot reference curves
ref = []
for path in opts.reference:
    if opts.verbose:
        print('reading reference curve from: '+path)
    ref.append(utils.load(path, columns, logcolumns=opts.logcolumn)[0])

#------------------------

### read in data from csv
if opts.verbose:
    print('reading samples from: '+inpath)
data, columns = utils.load(inpath, columns, logcolumns=opts.logcolumn, max_num_samples=opts.max_num_samples)

ranges = []
for i, col in enumerate(columns):
    if rangesdict.has_key(col):
        ranges.append(rangesdict[col])
    else:
        ranges.append((np.min(data[:,i]), np.max(data[:,i])))

if opts.whiten:
    data, means, stds = utils.whiten(data, verbose=opts.verbose)
    ranges = [((MIN-m)/s, (MAX-m)/s) for (MIN, MAX), m, s in zip(ranges, means, stds)]
    truths = [(val-m)/s if val is not None else val for val, m, s in zip(truths, means, stds)]
    ref = [np.array([(r[:,i]-m)/s for i, (m, s) in enumerate(zip(means, stds))]) for r in refs]

if opts.weight_column!=None:
    if opts.verbose:
        print('reading in non-trivial weights from: '+inpath)
    weights, _ = utils.load(inpath, [opts.weight_column], max_num_samples=opts.max_num_samples)
    weights = weights.reshape((len(weights)))

    if opts.weight_column_is_log:
        weights = np.exp(weights-np.max(weights))
    weights /= np.sum(weights)

else:
    N = len(data)
    weights = np.ones(N, dtype='float')/N

if opts.prune:### throw away data that's outside the bounds
    data, weights = utils.prune(data, ranges, weights=weights)

#------------------------

if opts.verbose:
    print('plotting')
fig = plot.kde_corner(
    data,
    bandwidths=bandwidths,
    truths=truths,
    truth_color=opts.truth_color,
    labels=labels,
    range=ranges,
    weights=weights,
    num_points=opts.num_points,
    color=opts.color,
    reflect=opts.reflect,
    verbose=opts.Verbose,
    hist1D=opts.hist1D,
    levels=opts.level,
    scatter=not opts.no_scatter,
    rotate=opts.rotate,
    figwidth=opts.figwidth,
    figheight=opts.figheight,
)

if opts.verbose and ref:
   print('plotting reference curves')
for r in ref:
    plot.curve_corner(
        r,
        labels=labels,
        range=ranges,
        color=opts.reference_color,
        verbose=opts.Verbose,
        fig=fig,
    )

if opts.include_neff:
    fig.suptitle('$N_\mathrm{eff} = %.1f$'%utils.neff(weights))

plot.save('kde_corner_samples%s'%opts.tag, fig, directory=opts.output_dir, figtypes=opts.figtype, dpi=opts.dpi, verbose=opts.verbose)
plot.plt.close(fig)
