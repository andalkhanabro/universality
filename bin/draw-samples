#!/usr/bin/env python

"""generate mass realizations from a prior and look up corresponding macroscopic properties
"""
__author__ = "reed.essick@gmail.com"

#-------------------------------------------------

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import priors

#-------------------------------------------------

def draw(mmin, mmax, size=utils.DEFAULT_NUM_DRAWS):
    """logic for generating mass samples
    """
    m = priors.sample_uniform(minval=mmin, maxval=mmax, size=Nsmp)
    logprior = priors.uniform(m, minval=mmin, maxval=mmax)
    return 

def lookup(m, paths, m_column=DEFAULT_MACRO_M_COLUMN, r_column=DEFAULT_MACRO_R_COLUMN):
    """logic for looking up macro parameters
    """
    curves []
    for path in paths:
        d, _ = utils.load(path, [m_column, r_column])
        curves.append( (np.min(d[:,0]), np.max(d[:,0]), d) )
    inds = np.arange(len(curves))
    r = []
    b = []
    for M in m:
        
        random.choice([d for mmin, mmax, d in curves if (mmin<=M) and (M<=mmax)])

    raise NotImplementedError

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('uids', nargs='+', type=int,
    help='the unique identifier numbers (EoS) for which we generate prior draws and write the result into outpath')
parser.add_argument('outpath', type=str)

parser.add_argument('--m-range', nargs=2, type=float, required=True)

parser.add_argument('--m-column', default='m', type=str)
parser.add_argument('--r-column', default='R', type=str)

parser.add_argument('--macro-m-column', default='M', type=str)
parser.add_argument('--macro-r-column', default='R', type=str)

parser.add_argument('-n', '--num-draws-per-eos', type=int, default=utils.DEFAULT_NUM_DRAWS)

parser.add_argument('--uid-column', default=utils.DEFAULT_UID_COLUMN, type=str)
parser.add_argument('--directory', default=utils.DEFAULT_OUTDIR, type=str)
parser.add_argument('--basename', default='draw-gpr-%(draw)06d.csv', type=str)
parser.add_argument('--num-per-directory', default=utils.DEFAULT_NUM_PER_DIRECTORY, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-V', '--Verbose', default=False, action='store_true')

args = parser.parse_args()

args.verbose |= args.Verbose

mmin, mmax = args.m_range

#-------------------------------------------------

### set up data structures
Nuid = len(args.uids)
Nsmp = Nuid*args.num_draws_per_eos

columns = [args.uid_column, args.m_column, 'logprior', 'branch', args.r_column]
Ncol = len(columns)

data = np.empty((Nsmp, Ncol), dtype=float)
for ind, uid in enumerate(args.uids):
    data[ind*args.num_draws_per_eos:(ind+1)*args.num_draws_per_eos] = uid

#------------------------

### draw variates
if args.verbose:
    print('drawing %d*%d=%d variates'%(Nuid, args.num_draws_per_eos, Nsmp))

m, logprior = draw(mmin, mmax, size=Nsmp)
data[:,1] = m
data[:,2] = logprior

#------------------------

### compute ordinates
if args.verbose:
    print('computing ordinates')

tmp = os.path.join(args.directory, 'DRAWmod%d'%args.num_per_directory+'-%(moddraw)06d', args.basenames)

for ind, uid in enumerate(args.uid):
    start = ind*args.num_draws_per_eos
    stop = (ind+1)*args.num_draws_per_eos

    paths = glob.glob(tmp%utils.draw2fmt(uid, num_per_directory=args.num_per_directory))
    branches, r = lookup(data[ind*args.num_draws_per_eos:(ind+1)*args.num_draws_per_eos, 1], args.macro_m_colum, args.macro_r_column, paths)
    data[start:stop,3] = branches
    data[start:stop,4] = r

#------------------------

### save the result
if args.verbose:
    print('saving samples to: '+args.outpath)
np.savetxt(args.outpath, data, delimiter=',', comments='', header=','.join(columns))
