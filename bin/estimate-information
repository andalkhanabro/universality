#!/usr/bin/env python

"""estimate the mutual information and entropy of a joint distribution over all specified columns.
Distributions are represented with KDEs and integrals are approximated with weighed Monte Carlo sums.
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality.utils import (utils, io)
from universality.kde.kde import silverman_bandwidth
from universality.stats.information import montecarloentropy

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('samples', type=str)
parser.add_argument('--weight-column', default=[], type=str, action='append')
parser.add_argument('--weight-column-is-log', default=[], type=str, action='append')

parser.add_argument('--max-num-samples', default=np.infty, type=float)

parser.add_argument("-v", '--verbose', default=False, action='store_true')
parser.add_argument("-V", '--Verbose', default=False, action='store_true')

parser.add_argument('columns', nargs='+', type=str)
parser.add_argument('--logcolumn', default=[], type=str, action='append')

parser.add_argument('-b', '--column-bandwidth', default=[], type=str, nargs=2,
    help='--column-bandwidth column val')
parser.add_argument('--num-proc', default=utils.DEFAULT_NUM_PROC, type=int,
    help='DEFAULT=%d'%utils.DEFAULT_NUM_PROC)

args = parser.parse_args()

args.verbose |= args.Verbose

for col in args.weight_column_is_log:
    assert col in args.weight_column, 'specifying --weight-column-is-log for unknown weight-column: '+col

variancedict = dict()
for column, b in args.column_bandwidth:
    assert column in args.columns, 'specifying --column-bandwidth for unknown column: '+column
    variancedict[column] = float(b)**2
variances = [variancedict.get(col, None) for col in args.columns] ### If None, will estimate automatically with Silverman's rule of thumb (for univariate data)

#-------------------------------------------------

### load data
if args.verbose:
    print('reading: '+args.samples)
data, columns = io.load(args.samples, columns=args.columns, logcolumns=args.logcolumn, max_num_samples=args.max_num_samples)
if args.verbose:
    print('found %d samples for %d columns'%(len(data), len(columns)))

if args.weight_column:
    if args.verbose:
        print('reading nontrivial weights from: %s'%(args.samples))
    weights = io.load_weights(args.samples, args.weight_column, logweightcolumns=args.weight_column_is_log, max_num_samples=args.max_num_samples)

    truth = weights>0
    data = data[truth,:]
    weights = weights[truth]
    if args.verbose:
        print('retained %d samples with non-zero weights'%(len(data)))

else:
    Nsamp = len(data)
    weights = np.ones(Nsamp, dtype=float)/Nsamp

#-------------------------------------------------

# compute entropy of each marginal distribution
if args.verbose:
    print('computing entropy of marginal distributions')

marginals = []

for i, (old_column, column) in enumerate(zip(args.columns, columns)): ### NOTE: may break if user passes duplicate columns...
    if args.verbose:
        print('computing entropy of marginal distribution for: '+column)

    ### determine bandwidth
    v = variances[i]
    if v is None:
        b = silverman_bandwidth(data[:,i], weights=weights) ### use bandwidth from overall marignal distrib
        if args.Verbose:
            print('automatically selected bandwidth=%.3e for col=%s'%(b, column))
        variances[i] = b**2

    h = montecarloentropy(
        data[:,i],
        weights=weights,
        variances=variances[i],
        verbose=args.Verbose,
        num_proc=args.num_proc,
    )
    marginals.append(h)

    # report
    print('    H(%s) = %.6e bits'%(column, h))

#------------------------

# compute marginal of the joint distribution
if args.verbose:
    print('computing entropy of the joint distribution')

variances = np.array(variances, dtype=float)

joint = montecarloentropy(
    data,
    weights=weights,
    variances=variances,
    verbose=args.Verbose,
    num_proc=args.num_proc,
)

# report
print('    H(joint) = %.6e bits'%(joint))

#------------------------

# compute mutual information
if args.verbose:
    print('computing mutual information of the joint distribution')
mutual_information = np.sum(marginals) - joint

# report
print('    mutual information = %.6e bits'%mutual_information)
