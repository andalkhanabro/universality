#!/usr/bin/env python

__usage__ = "investigate_gpr_dedp [--options] eos.csv min_sigma,max_sigma,num_sigma min_l,max_l,num_l min_sigma_obs,max_sigma_obs,num_sigma_obs"
__doc__ = "a simple script that investigates logLike as a function of the GPR hyper-parameters when attempting to regress de/dp from observations of e and p"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import sys

import numpy as np

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt

from optparse import OptionParser

### non-standard libraries
from universality import utils
from universality import gaussianprocess as gp

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__doc__)

parser.add_option('-v', '--verbose', default=False, action='store_true')

parser.add_option('', '--logspace-sigma', default=False, action='store_true')
parser.add_option('', '--logspace-l', default=False, action='store_true')
parser.add_option('', '--logspace-sigma_obs', default=False, action='store_true')

parser.add_option('-o', '--output-dir', default='.', type='string')
parser.add_option('-t', '--tag', default='', type='string')

opts, args = parser.parse_args()
assert len(args)==4, 'please supply exactly 4 input arguments\n%s'%__usage__
inpath = args[0]
min_sigma, max_sigma, num_sigma = [float(_) for _ in args[1].split(',')]
min_l, max_l, num_l = [float(_) for _ in args[2].split(',')]
min_sigma_obs, max_sigma_obs, num_sigma_obs = [float(_) for _ in args[3].split(',')]

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

if opts.tag:
    opts.tag = "_"+opts.tag

#-------------------------------------------------

### read in data
if opts.verbose:
    print('reading: '+inpath)
columns = ['energy_densityc2', 'pressurec2']
data, columns = utils.load(inpath, columns)

loge = np.log(data[:,0])
logp = np.log(data[:,1])

#------------------------

### evaluate logL on a grid
if opts.verbose:
    print('computing logL on a grid')

# set up grid
if opts.logspace_l:
    l = np.logspace(np.log10(min_l), np.log10(max_l), num_l)
else:
    l = np.linspace(min_l, max_l, num_l)

if opts.logspace_sigma:
    sigma = np.logspace(np.log10(min_sigma), np.log10(max_sigma), num_sigma)
else:
    sigma = np.linspace(min_sigma, max_sigma, num_sigma)

if opts.logspace_sigma_obs:
    sigma_obs = np.logspace(np.log10(min_sigma_obs), np.log10(max_sigma_obs), num_sigma_obs)
else:
    sigma_obs = np.linspace(min_sigma_obs, max_sigma_obs, num_sigma_obs)

L2, SIGMA2, SIGMA2_OBS = np.meshgrid(l**2, sigma**2, sigma_obs**2, indexing='ij')
N = num_l*num_sigma*num_sigma_obs

L2 = L2.flatten()
SIGMA2 = SIGMA2.flatten()
SIGMA2_OBS = SIGMA2_OBS.flatten()

logL = np.empty(N, dtype='float')
template = '\r[%4d / '+'%4d]'%N
for i in xrange(len(L2)):
    if opts.verbose:
        sys.stdout.write(template%(i+1))
        sys.stdout.flush()

    logL[i] = gp.logLike(loge, logp, sigma2=SIGMA2[i], l2=L2[i], sigma2_obs=SIGMA2_OBS[i])

### extract best parameters
best = logL.argmax()
best_logL = logL[best]
best_l = L2[best]**0.5
best_sigma = SIGMA2[best]**0.5
best_sigma_obs = SIGMA2_OBS[best]**0.5

if opts.verbose:
    print('\nmax(logL) = %.3e'%best_logL)
    print('    l = %.3e'%best_l)
    print('    sigma = %.3e'%best_sigma)
    print('    sigma_obs = %.3e'%best_sigma_obs)

### reshape logL and make a corner plot
logL = logL.reshape((num_l, num_sigma, num_sigma_obs))

### actually generate figure
if opts.verbose:
    print('  plotting')
fig = plt.figure()

# iterate through all pairs of columns, generating an axis for both
columns = ['l', '\sigma', '\sigma_\mathrm{obs}']
vects = [l, sigma, sigma_obs]
bests = [best_l, best_sigma, best_sigma_obs]
bounds = [(np.min(l), np.max(l)), (np.min(sigma), np.max(sigma)), (np.min(sigma_obs), np.max(sigma_obs))]

Ncol = 3
for row in xrange(Ncol):
    for col in xrange(row+1): ### only plot the lower-left triangle
        ax = plt.subplot(Ncol, Ncol, row*Ncol+col+1)

        # actually plot
        if row==col:
            axis = tuple([i for i in xrange(Ncol) if i!=row] + [row])
            ax.plot(vects[row], np.max(np.max(logL.transpose(axis), axis=0), axis=0))
            ylim = ax.get_ylim()
            ax.plot([bests[row]]*2, ylim, color='k')
            ax.set_ylim(ylim)

        else:
            axis = [i for i in xrange(Ncol) if i not in [row, col]][0] ### may be a little wasteful...            
            ax.contour(vects[col], vects[row], np.transpose(np.max(logL, axis=axis)))

            ax.plot([bests[col]]*2, bounds[row], color='k')
            ax.plot(bounds[col], [bests[row]]*2, color='k')

            # decorate a bit here
            # only set this if it is a 2D scatter plot!
            ax.set_ylim(bounds[row])

        # decorate                
        if row!=(Ncol-1):
            plt.setp(ax.get_xticklabels(), visible=False)
        else:
            ax.set_xlabel('$%s$'%columns[col])

        if col!=0 or row==0: #!=0
            plt.setp(ax.get_yticklabels(), visible=False)
        else:
            ax.set_ylabel('$%s$'%columns[row])

        ax.grid(True, which='both')
        plt.setp(ax.get_xticklabels(), rotation=45)

        ax.set_xlim(bounds[col])

# further decorate
fig.suptitle(os.path.basename(inpath)[:-4])
plt.subplots_adjust(
    hspace=0.1,
    wspace=0.1,
    left=0.11,
    right=0.98,
    bottom=0.13,
    top=0.95,
)

# save
figname = os.path.join(opts.output_dir, 'investigate_gpr_dedp-logLike%s.png'%(opts.tag))
if opts.verbose:
    print('saving: '+figname)
fig.savefig(figname)
plt.close(fig)

#------------------------

### feed logLike into a numeric minimization routine and extract the best hyper paarameters
raise NotImplementedError, '''\
feed this into a numeri optimization routine and let the computer figure out the best parameters
just print these and compare to the plot by eye? 
or actually annotate the plot from the grid with the selected "optimal"  hyperparameters?
'''
