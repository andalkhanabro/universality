#!/usr/bin/env python

__doc__ = "a simple script that investigates logLike as a function of the GPR hyper-parameters when attempting to regress de/dp from observations of e and p"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import sys

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import gaussianprocess as gp
from universality import plot

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

### required arguments
rgroup = parser.add_argument_group('required arguments')
rgroup.add_argument('eospath', type=str)
rgroup.add_argument('sigma_params', nargs=3, type=float,
    help='min_sigma max_sigma num_sigma')
rgroup.add_argument('length_scale_params', nargs=3, type=float,
    help='min_l max_l num_l')
rgroup.add_argument('sigma_obs_params', nargs=3, type=float,
    help='min_sigma_obs max_sigma_obs num_sigma_obs')

### verbosity options
vgroup = parser.add_argument_group('verbosity options')
vgroup.add_argument('-v', '--verbose', default=False, action='store_true')

### workflow options
wgroup = parser.add_argument_group('workflow options')
wgroup.add_argument('--logspace-sigma', default=False, action='store_true')
wgroup.add_argument('--logspace-l', default=False, action='store_true')
wgroup.add_argument('--logspace-sigma_obs', default=False, action='store_true')

### output options
ogroup = parser.add_argument_group('output options')
ogroup.add_argument('-o', '--output-dir', default='.', type=str)
ogroup.add_argument('-t', '--tag', default='', type=str)

args = parser.parse_args()

min_sigma, max_sigma, num_sigma = args.sigma_params
min_l, max_l, num_l = args.length_scale_params
min_sigma_obs, max_sigma_obs, num_sigma_obs = args.sigma_obs_params

if not os.path.exists(args.output_dir):
    os.makedirs(args.output_dir)

if args.tag:
    args.tag = "_"+args.tag

#-------------------------------------------------

### read in data
if args.verbose:
    print('reading: '+args.eospath)
columns = ['energy_densityc2', 'pressurec2']
data, columns = utils.load(args.eospath, columns)

loge = np.log(data[:,0])
logp = np.log(data[:,1])

#------------------------

### evaluate logL on a grid
if args.verbose:
    print('computing logL on a grid')

# set up grid
if args.logspace_l:
    l = np.logspace(np.log10(min_l), np.log10(max_l), num_l)
else:
    l = np.linspace(min_l, max_l, num_l)

if args.logspace_sigma:
    sigma = np.logspace(np.log10(min_sigma), np.log10(max_sigma), num_sigma)
else:
    sigma = np.linspace(min_sigma, max_sigma, num_sigma)

if args.logspace_sigma_obs:
    sigma_obs = np.logspace(np.log10(min_sigma_obs), np.log10(max_sigma_obs), num_sigma_obs)
else:
    sigma_obs = np.linspace(min_sigma_obs, max_sigma_obs, num_sigma_obs)

L2, SIGMA2, SIGMA2_OBS = np.meshgrid(l**2, sigma**2, sigma_obs**2, indexing='ij')
N = num_l*num_sigma*num_sigma_obs

L2 = L2.flatten()
SIGMA2 = SIGMA2.flatten()
SIGMA2_OBS = SIGMA2_OBS.flatten()

logL = np.empty(N, dtype='float')
template = '\r[ %6d / '+'%6d ]'%N
for i in xrange(len(L2)):
    if args.verbose:
        sys.stdout.write(template%(i+1))
        sys.stdout.flush()

    logL[i] = gp.logLike(loge, logp, sigma2=SIGMA2[i], l2=L2[i], sigma2_obs=SIGMA2_OBS[i])

### extract best parameters
best = logL.argmax()
best_logL = logL[best]
best_l = L2[best]**0.5
best_sigma = SIGMA2[best]**0.5
best_sigma_obs = SIGMA2_OBS[best]**0.5

if args.verbose:
    print('\nmax(logL) = %.3e'%best_logL)
    print('    l = %.3e'%best_l)
    print('    sigma = %.3e'%best_sigma)
    print('    sigma_obs = %.3e'%best_sigma_obs)

### reshape logL and make a corner plot
logL = logL.reshape((num_l, num_sigma, num_sigma_obs))

### actually generate figure
if args.verbose:
    print('  plotting')
fig = plot.plt.figure()

# iterate through all pairs of columns, generating an axis for both
columns = ['l', '\sigma', '\sigma_\mathrm{obs}']
vects = [l, sigma, sigma_obs]
bests = [best_l, best_sigma, best_sigma_obs]
bounds = [(np.min(l), np.max(l)), (np.min(sigma), np.max(sigma)), (np.min(sigma_obs), np.max(sigma_obs))]
scales = []
scales.append('log' if args.logspace_l else 'linear')
scales.append('log' if args.logspace_sigma else 'linear')
scales.append('log' if args.logspace_sigma_obs else 'linear')

Ncol = 3
alpha = 0.5 ### used for cross-hairs
for row in xrange(Ncol):
    for col in xrange(row+1): ### only plot the lower-left triangle
        ax = plot.plt.subplot(Ncol, Ncol, row*Ncol+col+1)

        # actually plot
        if row==col:
            axis = tuple([i for i in xrange(Ncol) if i!=row] + [row])
            ax.plot(vects[row], np.max(np.max(logL.transpose(axis), axis=0), axis=0))
            ylim = ax.get_ylim()
            ax.plot([bests[row]]*2, ylim, color='k', alpha=alpha)
            ax.set_ylim(ylim)

        else:
            axis = [i for i in xrange(Ncol) if i not in [row, col]][0] ### may be a little wasteful...            
            ax.contour(vects[col], vects[row], np.transpose(np.max(logL, axis=axis)))

            ax.plot([bests[col]]*2, bounds[row], color='k', alpha=alpha)
            ax.plot(bounds[col], [bests[row]]*2, color='k', alpha=alpha)

            # decorate a bit here
            # only set this if it is a 2D scatter plot!
            ax.set_yscale(scales[row])
            ax.set_ylim(bounds[row])

        # decorate                
        if row!=(Ncol-1):
            plot.plt.setp(ax.get_xticklabels(), visible=False)
        else:
            ax.set_xlabel('$%s$'%columns[col])

        if col!=0 or row==0: #!=0
            plot.plt.setp(ax.get_yticklabels(), visible=False)
        else:
            ax.set_ylabel('$%s$'%columns[row])

        ax.grid(True, which='both')
        plot.plt.setp(ax.get_xticklabels(), rotation=45)

        ax.set_xscale(scales[col])
        ax.set_xlim(bounds[col])

# further decorate
fig.suptitle(os.path.basename(args.eospath)[:-4])
plot.plt.subplots_adjust(
    hspace=0.1,
    wspace=0.1,
    left=0.11,
    right=0.98,
    bottom=0.13,
    top=0.95,
)

# save
figname = os.path.join(args.output_dir, 'investigate_gpr_dedp-logLike%s.png'%(args.tag))
if args.verbose:
    print('saving: '+figname)
fig.savefig(figname)
plot.plt.close(fig)

#------------------------

### feed logLike into a numeric minimization routine and extract the best hyper paarameters
raise NotImplementedError, '''\
feed this into a numeri optimization routine and let the computer figure out the best parameters
just print these and compare to the plot by eye? 
or actually annotate the plot from the grid with the selected "optimal"  hyperparameters?
'''
