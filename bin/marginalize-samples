#!/usr/bin/env python

"""marginalize over all weights associated with combinations of columns, creating a new file with marginalized weights within it
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os
import sys
import numpy as np

from collections import defaultdict
from argparse import ArgumentParser

### non-standard libraries
from universality import utils

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('samples', type=str)
parser.add_argument('columns', nargs="+", type=str,
    help='columns used to define unique sets. We will marginalize over anything not specified here')

parser.add_argument('--weight-column', default=[], type=str, action='append')
parser.add_argument('--weight-column-is-log', default=[], type=str, action='append')
parser.add_argument('--max-num-samples', default=utils.DEFAULT_MAX_NUM_SAMPLES, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-o', '--output-path', default=None, type=str,
    help='print to this file if specified. Otherwise we print to STDOUT.')

args = parser.parse_args()

#-------------------------------------------------

if args.verbose:
    print('reading samples from: '+args.samples)
data, columns = utils.load(args.samples, args.columns, max_num_samples=args.max_num_samples)

if args.weight_column:
    if args.verbose:
        print('reading in non-trivial weights from: '+args.samples)
    logweights = utils.load_logweights(
        args.samples,
        args.weight_column,
        logweightcolumns=args.weight_column_is_log,
        max_num_samples=args.max_num_samples,
    )

else:
    N = len(data)
    logweights = np.zeros(N, dtype='float')

# now need to marginalize over samples
if args.verbose:
    print('marginalizing over weights to determine effective weights for unique combinations of (%s)'%(', '.join(args.columns)))

logmargweight = defaultdict(float)
counts = defaultdict(int)
for sample, logweight in zip(data, logweights):
    tup = tuple(sample)
    logmargweight[tup] = utils.sum_log((logmargweight.get(tup, -np.infty), logweight))
    counts[tup] += 1 

num_columns = len(columns)
columns = columns+['logmargweight', 'num_elements'] ### store the columns requested, the marginalized weight, and the number of elements included in the set for this particular tuple

# format the array as needed
if args.verbose:
    print('reformatting data into an array...')
results = np.empty((len(logmargweight.keys()), len(columns)), dtype=float)
for i, key in enumerate(logmargweight.keys()):
    results[i,:num_columns] = key
    results[i,num_columns:] = logmargweight[key], counts[key]

# write output CSV file
if args.output_path is not None:
    if args.verbose:
        print('writing marginalized results to: '+args.output_path)

    outdir = os.path.dirname(args.output_path)
    if not os.path.exists(outdir):
        os.makedirs(outdir)

else:
    args.output_path = sys.stdout ### write to STDOUT

np.savetxt(args.output_path, results, header=','.join(columns), comments='', delimiter=',')
