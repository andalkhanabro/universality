#!/usr/bin/env python

"""a script to make a heatmap of a process by summing the cumulative amount of weight assigned to each pixel within a pre-computed raster
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os
import glob

from collections import defaultdict

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import plot

#-------------------------------------------------

DEFAULT_NUM_PIXELS = 1024
DEFAULT_HA = 'left'
DEFAULT_VA = 'top'

DEFAULT_EOS_COLUMN = 'EoS'
DEFAULT_EOS_DIR = '.'
DEFAULT_EOS_NUM_PER_DIR = 1000
DEFAULT_EOS_BASENAME = 'draw-foo-%d.csv'

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

rgroup = parser.add_argument_group('required arguments')
rgroup.add_argument('-s', '--samples', required=True, nargs=2, default=[], type=str, action='append',
    help='e.g.: "--samples label path/to/samples.csv"')

rgroup.add_argument('ycolumn', type=str)
rgroup.add_argument('xcolumn', type=str)

rgroup.add_argument('xmin', type=float)
rgroup.add_argument('xmax', type=float)
rgroup.add_argument('ymin', type=float)
rgroup.add_argument('ymax', type=float)

# workflow argumnets
wgroup = parser.add_argument_group('workflow arguments')
wgroup.add_argument('--num-points', default=101, type=int,
    help='the number of interpolation points used when plotting (resample each curve to this number of points before discretizing to raster)')
wgroup.add_argument('--num-x-pixels', default=DEFAULT_NUM_PIXELS, type=int)
wgroup.add_argument('--num-y-pixels', default=DEFAULT_NUM_PIXELS, type=int)

# samples arguments
sgroup = parser.add_argument_group('samples-specific argument')
sgroup.add_argument('-m', '--max-num-samples', nargs=2, default=[], type=str, action='append',
    help='label max-num-samples pairs')
sgroup.add_argument('-w', '--weight-column', nargs=2, default=[], type=str, action='append',
    help='label column pairs. if provided, thie numerical values from this column will be used as weights in the KDE')
sgroup.add_argument('-W', '--weight-column-is-log', nargs=2, default=[], type=str, action='append',
    help='the label and column for samples for which this is true')

# lookup arguments
lgroup = parser.add_argument_group('look-up arguments')
lgroup.add_argument('--eos-column', nargs=2, default=[], type=str, action='append',
    help='e.g.: "--eos-column label EoS')

lgroup.add_argument('--eos-dir', nargs=2, default=[], type=str, action='append',
    help='e.g.: "--eos-dir label path/to/directory"')
lgroup.add_argument('--eos-num-per-dir', nargs=2, default=[], type=str, action='append',
    help='a label and a string for the number of samples per directory')
lgroup.add_argument('--eos-basename', nargs=2, default=[], type=str, action='append',
    help='a label and a string into which the EOS number can be substituted when building filenames. NOTE, we glob for filenames, so if you wish to specify a subdirectory you can just provide the appropriate glob string and pick up everything underneath (useful for macroscopic properies of EOS).')

# column arguments
cgroup = parser.add_argument_group('column-specific arguments')
cgroup.add_argument('-l', '--logcolumn', default=[], type=str, action='append',
    help='convert the values read in for this column to natural log. \
Can be repeated to specify multiple columns. \
DEFAULT=[]')
cgroup.add_argument('-L', '--column-label', nargs=2, default=[], type=str, action='append',
    help='replace the column name with this label in the corner plot. e.g.: \'xcol $x$\'. \
DEFAULT=[]')

# plotting options
pgroup = parser.add_argument_group('plotting options')

pgroup.add_argument('--reference', default=[], nargs=2, type=str, action='append',
    help='e.g.: "--reference name path". path to a reference CSV that will be plotted on top of the process plot. Can be repeated to specify multiple reference curves. \
The columns must be the same as those supplied in the input arguments. \
DEFAULT=[]')

pgroup.add_argument('--color-map', nargs=2, action='append', default=[], type=str,
    help='e.g. "--color-map label c"')
pgroup.add_argument('--truth-color', default=plot.DEFAULT_TRUTH_COLOR, type=str)
pgroup.add_argument('--reference-color', nargs=2, type=str, default=[], action='append',
    help='e.g.: "--reference-color name b"')
pgroup.add_argument('--annotation-color', nargs=2, type=str, default=[], action='append',
    help='e.g.: "--annotation-color name b"')

pgroup.add_argument('--annotation-marker', nargs=2, type=str, default=[], action='append',
    help='e.g.: "--annotation-marker name o"')
pgroup.add_argument('--annotation-ha', nargs=2, type=str, default=[], action='append',
    help='e.g.: "--annotation-marker name left"')
pgroup.add_argument('--annotation-va', nargs=2, type=str, default=[], action='append',
    help='e.g.: "--annotation-marker name top"')

pgroup.add_argument('--interpolation', default='bilinear', type=str,
    help='the interpolation algorithm used within imshow')

pgroup.add_argument('--figwidth', default=plot.DEFAULT_FIGWIDTH, type=float)
pgroup.add_argument('--figheight', default=plot.DEFAULT_FIGHEIGHT, type=float)

pgroup.add_argument('--grid', default=False, action='store_true')

# annotation options
agroup = parser.add_argument_group('annotation options')
agroup.add_argument('--signpost', nargs=2, default=[], type=str, action='append',
    help='add markers (vertical/horizontal lines) to denote specific values. e.g.: "baryon_density 2.7e14". Can be repeated')
agroup.add_argument('--signpost-color', default=plot.DEFAULT_TRUTH_COLOR, type=str)
agroup.add_argument('--annotation', default=[], nargs=3, type=str, action='append',
    help='add annotations on top of the heatmap e.g.: "--annotation name xvalue yvalue"')

# verbosity arguments
vgroup = parser.add_argument_group('verbosity arguments')
vgroup.add_argument('-v', '--verbose', default=False, action='store_true')
vgroup.add_argument('-V', '--Verbose', default=False, action='store_true')

# ouptut options
ogroup = parser.add_argument_group('output options')
ogroup.add_argument('-o', '--output-dir', default='.', type=str)
ogroup.add_argument('-t', '--tag', default='', type=str)
ogroup.add_argument('--figtype', default=[], type=str, action='append')
ogroup.add_argument('--dpi', default=plot.DEFAULT_DPI, type=float)

args = parser.parse_args()

### finish parsing
columns = [args.xcolumn, args.ycolumn]
names = [label for label, path in args.samples]
reference_names = [label for label, path in args.reference]

Nsamples = len(names)

# samples arguments
max_num_samples = dict((label, np.infty) for label in names)
for label, num in args.max_num_samples:
    assert label in names, 'specifying --max-num-sample for unknown sample set: '+label
    max_num_samples[label] = int(num)

weight_columns = dict((label, ([], [])) for label in names)
for label, column in args.weight_column:
    assert label in names, 'specifying --weight-column for unknown sample set: '+label
    weight_columns[label][0].append(column)
for label, column in args.weight_column_is_log:
    assert label in names, 'specifying --weight-column-is-log for unknown sample set: '+label
    weight_columns[label][1].append(column)

eos_dirs = dict((label, DEFAULT_EOS_DIR) for label in names)
for label, directory in args.eos_dir:
    assert label in names, 'specifying --eos-dir for unknown sample set: '+label
    eos_dirs[label] = directory

eos_num_per_dir = dict((label, DEFAULT_EOS_NUM_PER_DIR) for label in names)
for label, num in args.eos_num_per_dir:
    assert label in names, 'specifying --eos-num-per-dir for unknown sample set: '+label
    eos_num_per_dir[label] = int(num)

eos_basenames = dict((label, DEFAULT_EOS_BASENAME) for label in names)
for label, basename in args.eos_basename:
    assert label in names, 'specigying --eos-basename for unknown sample set: '+label
    eos_basenames[label] = basename

eos_temps = dict((label, os.path.join(eos_dirs[label], 'DRAWmod%d'%eos_num_per_dir[label]+'-%(moddraw)06d', eos_basenames[label])) for label in names)

eos_columns = dict((label, DEFAULT_EOS_COLUMN) for label in names)
for label, column in args.eos_column:
    assert label in names, 'specifying --eos-column for unknown sample set: '+label
    eos_columns[label] = column

# verbosity options
args.verbose |= args.Verbose

# column options
labels = dict((col, '$'+col+'$') for col in columns)
for column, label in args.column_label:
    assert column in columns, 'specifying --column-label for unknown column: '+column
    labels[column] = label

# plotting options
colormaps = dict((label, plot.DEFAULT_COLORMAP) for label in names)
for label, colormap in args.color_map:
    assert label in names, 'specifying --color-map for uknown sample set: '+label
    colormaps[label] = colormap

reference_colors = dict((label, plot.DEFAULT_TRUTH_COLOR) for label in reference_names)
for label, color in args.reference_color:
    assert label in reference_names, 'specifying --reference-color for unknown reference set: '+label
    reference_colors[label] = color

# annotation options
signposts = defaultdict(list)
for column, value in args.signpost:
    assert column in columns, 'specifying --signpost for unknown column: '+column
    signposts[column].append(float(value))

annotations = dict((name, (float(x), float(y), plot.DEFAULT_TRUTH_COLOR, plot.DEFAULT_MARKER, DEFAULT_HA, DEFAULT_VA)) for name, x, y in args.annotation)
for name, color in args.annotation_color:
    assert name in annotations, 'specifying --annotation-color for unknown annotation: '+name
    x, y, _, m, ha, va = annotations[name]
    annotations[name] = x, y, color, m, ha, va
for name, marker in args.annotation_marker:
    assert name in annotations, 'specifying --annotation-marker for unkown annotation: '+name
    x, y, c, _, ha, va = annotations[name]
    annotations[name] = x, y, c, marker, ha, va
for name, horizontal in args.annotation_ha:
    assert name in annotations, 'specifying --annotation-ha for unkown annotation: '+name
    x, y, c, m, _, va = annotations[name]
    annotations[name] = x, y, c, m, horizontal, va
for name, vertical in args.annotation_va:
    assert name in annotations
    x, y, c, m, ha, _ = annotations[name]
    annotations[name] = x, y, c, m, ha, va

# output options
if args.output_dir and (not os.path.exists(args.output_dir)):
    os.makedirs(args.output_dir)

if args.tag:
    args.tag = "_"+args.tag

if not args.figtype:
    args.figtype = plot.DEFAULT_FIGTYPES

logx = args.xcolumn in args.logcolumn
logy = args.ycolumn in args.logcolumn

#-------------------------------------------------

fig = plot.plt.figure(figsize=(args.figwidth, args.figheight))
ax = fig.add_axes(plot.AXES_POSITION)

### set up the indexing arrays
raster = np.zeros((args.num_y_pixels, args.num_x_pixels, 4), dtype=float) ### assume RGB-alpha color notation

if logx:
    x_register = np.logspace(np.log10(args.xmin), np.log10(args.xmax), args.num_x_pixels+1)
else:
    x_register = np.linspace(args.xmin, args.xmax, args.num_x_pixels+1)

if logy:
    y_register = np.logspace(np.log10(args.ymin), np.log10(args.ymax), args.num_y_pixels+1)
else:
    y_register = np.linspace(args.ymin, args.ymax, args.num_y_pixels+1)

### set up the raster for these pixels
count = np.empty((args.num_y_pixels, args.num_x_pixels), dtype=float)
count_truth = np.empty((args.num_y_pixels, args.num_x_pixels), dtype=bool)

alpha = 1./len(args.samples) ### the number of samples we have

### iterate over samples, generating a raster for each set
for label, path in args.samples:

    count[:] = 0. ### zero this out

    if args.verbose:
        print('reading samples for %s from %s in: %s'%(label, eos_columns[label], path))
    data, cols = utils.load(path, [eos_columns[label]], max_num_samples=max_num_samples[label])

    if weight_columns[label][0]:
        if args.verbose:
            print('reading in non-trivial weights from: '+path)
        weights = utils.load_weights(path, weight_columns[label][0], logweightcolumns=weight_columns[label][1], max_num_samples=max_num_samples[label])

    else:
        N = len(data)
        weights = np.ones(N, dtype='float')/N

    ### marginalize to avoid reading in the same EOS more than once
    if args.verbose:
        print('marginalizing samples to avoid repeated work reading the same EoS multiple times')
    data, cols = utils.marginalize(data, np.log(weights), cols)
    weights = utils.exp_weights(data[:,cols.index('logmargweight')])
    data = data[:,0]

    ### prune samples to get rid of vanishing weights
    truth = weights > 0
    data = data[truth]
    weights = weights[truth]
    N = len(data)

    ### iterate over the EOS
    eos_temp = eos_temps[label]
    eos_mod = eos_num_per_dir[label]

    if args.verbose:
        print('iterating over unique values of: '+eos_columns[label])
    for eos, weight in zip(data, weights):
        for eos_path in glob.glob(eos_temp%{'moddraw':eos//eos_mod, 'draw':eos}):
            if args.Verbose:
                print('    '+eos_path)
            d, _ = utils.load(eos_path, columns)

            truth = (d[:,0]>=args.xmin)*(d[:,0]<=args.xmax)*(d[:,1]>=args.ymin)*(d[:,1]<=args.ymax)
            if not np.sum(truth):
                continue ### nothing to plot anyway

            ### throw away stuff that won't be plotted anyway
            ### makes sure we upsample to a reasonable number of points within the plotting window
            inds = np.arange(len(d))
            data = data[inds[truth][0]-1:inds[truth][-1]+1]

            ### upsample data and find the pixels it intersects
            if logx:
                d[:,0] = np.log(d[:,0])
            if logy:
                d[:,1] = np.log(d[:,1])
            X, Y = utils.upsample(d[:,0], d[:,1], args.num_points)
            if logx:
                X = np.exp(X)
            if logy:
                Y = np.exp(Y)

#            ax.plot(X, Y, marker='o', linestyle='none', markeredgecolor='k', markerfacecolor='none', alpha=0.1)

            ### only add weight once to each pixel even if the upsampled curve hits that pixel more than once
            count_truth[:] = False
            for x, y in zip(X, Y):
                count_truth[:] = np.logical_or(count_truth, np.outer((y >= y_register[:-1])*(y < y_register[1:]), (x >= x_register[:-1])*(x < x_register[1:])))

            if np.any(count_truth):
                count[count_truth] += weight ### actually increment the count

    # normalize count so it runs between 0, 1
    if np.max(count) > 0:
        count /= np.max(count)

    # convert to colors and update overall raster
    raster[:,:,:3] += plot.cm.get_cmap(colormaps[label])(count)[:,:,:3]*alpha

raster[:,:,3] = 1.0 ### set the alpha value for the raster
                    ### we rely on having managed the relative alpha values within the previous loop

### load in reference curves
reference = [] # define this out here so other loops can iterate over it even if we don't have any reference curves...
if args.reference:
    for label, path in args.reference:
        if args.verbose:
            print('reading reference curve from: '+path)
        reference.append((label, utils.load(path, columns)[0])) ### just grab the data, not the column names

#-------------------------------------------------

if args.verbose:
    print('plotting')

ax.imshow(
    raster,
    origin='lower',
    extent=(x_register[0], x_register[-1], y_register[0], y_register[-1]),
    aspect='auto',
    interpolation=args.interpolation,
)

# add reference curves
for ref_label, curve in reference:
    X = curve[:,0]
    Y = curve[:,1]
    color = reference_colors[ref_label]
    ax.plot(X, Y, color=color, alpha=0.5)

# add annotations
for name, (x, y, c, m, ha, va) in annotations.items():
    ax.plot(x, y, color=c, marker=m)
    ax.text(x, y, name, color=c, ha=ha, va=va)

# scaling, etc
if logx:
    ax.set_xscale('log')
if logy:
    ax.set_yscale('log')

ax.grid(args.grid, which='both')

# set limits
ax.set_xlim(xmin=args.xmin, xmax=args.xmax)

ax.set_ylim(ymin=args.ymin, ymax=args.ymax)

### add signposts
ylim = ax.get_ylim()
for value in signposts[args.xcolumn]:
    ax.plot([value]*2, ylim, color=args.signpost_color)
ax.set_ylim(ylim)

xlim = ax.get_xlim()
for value in signposts[args.ycolumn]:
    ax.plot(xlim, [value]*2, color=args.signpost_color)
ax.set_xlim(xlim)

# set labels
ax.set_ylabel(labels[args.ycolumn])
ax.set_xlabel(labels[args.xcolumn])

# save
plot.save('plot-process%s'%args.tag, fig, directory=args.output_dir, figtypes=args.figtype, dpi=args.dpi, verbose=args.verbose)
plot.close(fig)
