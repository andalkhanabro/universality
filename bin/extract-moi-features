#!/usr/bin/env python

"""a script that processes macroscipic relations between the mass and moment of inertia (MoI) in order to identify and characterize phase transitoins"""
__author__ = "reed.essick@gmail.com"

#-------------------------------------------------

import os
import sys
import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import gaussianprocess as gp
from universality import plot as plt

#-------------------------------------------------

MAX_CS2C2_TEMPLATE = 'max_cs2c2_%s'
#MAX_K_TEMPLATE = 'max_k_%s'
MIN_CS2C2_TEMPLATE = 'min_cs2c2_%s'
MAX_DCS_DP_TEMPLATE = 'max_dcs2_dpressure_%s'
MIN_ARCTAN_DLNI_DLNM_TEMPLATE = 'min_arctan_dlnI_dlnM_%s'

def identify_phase_transitions(
        rhoc,
        M,
        I,
        baryon_density,
        cs2c2,
        pressurec2,
        macro_data,
        macro_cols,
        eos_data,
        eos_cols,
        flatten_thr=0.0,
        smoothing_width=None,
        diff_thr=0.0,
        verbose=False,
        cs2c2_cofactor=3.0, ### should be a conservative bound...
    ):
    """
    looks for specific behavior in arctan(dlnI/dlnM) that seems to correspond to phase transitions.
    returns the corresponding values from data along with names based on cols
    """
    names = ['transition']
    for tmp in [
            MIN_CS2C2_TEMPLATE,
            MAX_CS2C2_TEMPLATE,
            MAX_DCS_DP_TEMPLATE,
            MIN_ARCTAN_DLNI_DLNM_TEMPLATE,
        ]:
        names += [tmp%col for col in macro_cols]
        names += [tmp%col for col in eos_cols]
    params = []

    ### compute the absolute value of the curvature, which we use as an indicator variable
    arctan_dlnI_dlnM, (spurious, dlnM_drhoc, dlnI_drhoc) = arctan_transform(rhoc, M, I, flatten_thr=flatten_thr, smoothing_width=smoothing_width)

    ### find the possible end points as local minima of arctan_dlnI_dlnM
    ends = list(find_inclusive_minima(arctan_dlnI_dlnM)[::-1]) ### reverse so the ones with largest rhoc are first

    ### discard any local minima that are before the first stable branch
    while len(ends):
        end = ends[-1]
        if np.any(dlnM_drhoc[:end] > 0): ### something is stable before this
             break
        ends = ends[:-1] ### truncate this guy

    ### discard any local minima that are in the final unstable branch
    while len(ends):
        end = ends.pop(0)
        if np.any(dlnM_drhoc[end:] > 0): ### not part of the 'final unstable branch'
            ends.insert(0, end)
            break

    if ends: ### we have something to do

        ### if the lowest rhoc available is a minimum, we discard it since we can't tell if it is a local minimum or not
        if ends[-1] == 0:
            ends = ends[:-1]

        if ends[0] == len(rhoc)-1: ### same thing with the end point
            ends = ends[1:]

        ### local minima in sound speed
        min_cs2c2 = find_inclusive_minima(cs2c2)
        min_cs2c2 = np.array(min_cs2c2)
        min_cs2c2_baryon_density = baryon_density[min_cs2c2]

        ### global maxima in sound speed up to the current point
        max_cs2c2 = find_running_maxima(cs2c2)

        if not max_cs2c2: ### no qualifying maxima
            ends = [] ### this will make us skip all the ends because we can't match them to starting points
        else:
            max_cs2c2 = np.array(max_cs2c2)
            max_cs2c2_baryon_density = baryon_density[max_cs2c2]

        ### maxima of dcs2c2_dpressurec2
        max_dcs_dpressure = np.array(find_maxima(gp.num_dfdx(pressurec2, cs2c2)))
        max_dcs_dpressure_baryon_density = baryon_density[max_dcs_dpressure]

        # iterate through and grab the following associated with each "end"
        Neos = len(eos_cols)
        Nmac = len(macro_cols)
        last_r = +np.infty ### logic to avoid overlapping phase transitions
        group = []
        for end in ends:
            r = rhoc[end]
            datum = []

            if verbose:
                print('    processing end=%d/%d at rhoc=%.6e'%(end, len(rhoc), r))

            ### min sound speed preceeding "end"
            try:
                ind = find_preceeding(r, min_cs2c2_baryon_density, min_cs2c2)
            except RuntimeError:
                if verbose:
                    print('    WARNING! coult not find preceeding minimum in cs2c2')
                continue

            min_r = baryon_density[ind]
            min_cs2c2_arctan = np.interp(min_r, rhoc, arctan_dlnI_dlnM)

            datum += [np.interp(baryon_density[ind], rhoc, macro_data[:,i]) for i in range(Nmac)]
            datum += list(eos_data[ind])

            ### max sound speed preceeding "end"
            try:
                ind = find_preceeding(min_r, max_cs2c2_baryon_density, max_cs2c2) ### look for local max before the local min
            except RuntimeError:
                if verbose:
                    print('    WARNING! could not find preceeding maximum in cs2c2')
                continue

            max_r = baryon_density[ind] ### expect max(cs2c2) to be the smallest density (required if we're to keep this possible transition)
            max_cs2c2_arctan = np.interp(max_r, rhoc, arctan_dlnI_dlnM)

            if (dlnM_drhoc[end] > 0) and (np.max(arctan_dlnI_dlnM[(max_r<=rhoc)*(rhoc<=r)]) - arctan_dlnI_dlnM[end] < diff_thr): ### does not pass our basic selection cut for being "big enough". Note that we add an exception if we're on an unstable branch (that's gotta be a strong phase transition...)
                if verbose:
                    print('    WARNING! difference in arctan_dlnI_dlnM is smaller than diff_thr; skipping this possible transition')
                continue

            if max(max_cs2c2_arctan, min_cs2c2_arctan) < arctan_dlnI_dlnM[end]: ### both are smaller, so we're kinda on an "upward sweep" that typically doesn't correspond to the behavior we want
                if verbose:
                    print('    WARNING! arctan(dlnI/dlnM) at max_cs2c2 and min_cs2c2 is less than at the local minimum; skipping this possible transition')
                continue

            if np.interp(r, baryon_density, cs2c2) > cs2c2_cofactor*cs2c2[ind]: ### recovery occurs at a larger sound speed than the onset...
                if verbose:
                    print('    WARNING! sound-speed at local minimum is larger than onset sound speed; skipping this possible transition')
                continue

            datum += [np.interp(max_r, rhoc, macro_data[:,i]) for i in range(Nmac)]
            datum += list(eos_data[ind])

            ### parameters of max dcs2_dpressure
            try:
                ind = find_following(min_r, max_dcs_dpressure_baryon_density, max_dcs_dpressure) ### maximum after min(cs2c2)
            except RuntimeError:
                if verbose:
                    print('    WARNING! could not find the following maximum in dcs2c2_dpressurec2')
                continue

            max_dcs_r = baryon_density[ind]

            datum += [np.interp(max_dcs_r, rhoc, macro_data[:,i]) for i in range(Nmac)]
            datum += list(eos_data[ind])

            ### parameters at "end"
            ind = end
            datum += list(macro_data[end])
            datum += [np.interp(r, baryon_density, eos_data[:,i]) for i in range(Neos)]

            ### figure out if there is any overlap, keep the one with the minimum dlnI_drhoc[end]
            if len(group) and (r < last_r): ### we already have a group and this would *not* overlap with something we've already declared a phase transition, so figure out which is best and add it
                group.sort(key=lambda x:x[0]) ### sort so the smallest dlnI_drhoc is first
                params.append(group[0][1]) ### append the datum
                group = [] ### start a new group
#            group.append((arctan_dlnI_dlnM[end], datum))
            group.append((rhoc[end], datum)) ### FIXME: this whole "group" logic may be wasteful of memory if we know we're going to order by rhoc and we already iterate based on samples ordered by rhoc...

            last_r = min_r ### update this so we remember the extent of the current phase transition (avoid overlaps with the next one)

        if group: ### add the last identified transition
#            group.sort(key=lambda x:x[0])
            group.sort(key=lambda x: -x[0]) ### bigger rhoc first
            params.append(group[0][1])

    params = [[ind]+thing for ind, thing in enumerate(params)] ### include a transition number for reference

    if not len(params):
        params = np.empty((0,len(names)), dtype=float)

    else:
        params = np.array(params, dtype=float)

    return params, names

def find_preceeding(x_ref, x, y):
    '''assumes x is ordered from decreasing to increasing'''
    found = x <= x_ref
    if np.sum(found):
        return y[found][-1]
    else:
        raise RuntimeError('no preceeding value found!')

def find_following(x_ref, x, y):
    '''assumes x is ordered from decreasing to increasing'''
    return find_preceeding(-x_ref, -x[::-1], y[::-1])

def find_running_maxima(x):
    """find the indecies of the largest thing that's been seen up until the current index"""
    return find_running_minima(-np.array(x))

def find_running_minima(x):
    """find the indecies of the smallest thing that's been seen up until the current index"""
    mins = []
    best = +np.infty
    for i, X in enumerate(x):
        if X < best:
            mins.append(i)
            best = X
    return mins

def find_maxima(x):
    """find indecies of strict local maxima"""
    return find_minima(-np.array(x))

def find_minima(x):
    """find indecies of strict local minima"""
    mins = []
    old = +np.infty
    for i in range(len(x)-1):
        new = x[i]
        if (old > new) and (new < x[i+1]):
            mins.append(i)
        old = new
    if x[i+1] > x[i]:
        mins.append(i+1)
    return mins

def find_inclusive_minima(x):
    """find indecies of local minima, including cases when the value does not change from one sample to the next"""
    mins = []
    old = +np.infty
    for i in range(len(x)-1):
        new = x[i]
        if (old >= new) and (new <= x[i+1]):
            mins.append(i)
        old = new
    if x[i+1] > x[i]:
        mins.append(i+1)
    return mins

def arctan_transform(rhoc, M, I, flatten_thr=0., smoothing_width=None):
    """compute the special arctan function we use to feed into our feature identification function
    """
    dlnI_drhoc = gp.num_dfdx(rhoc, I) / I
    dlnM_drhoc = gp.num_dfdx(rhoc, M) / M

    if smoothing_width:
        dlnI_drhoc = smooth(np.log(rhoc), dlnI_drhoc, smoothing_width)
        dlnM_drhoc = smooth(np.log(rhoc), dlnM_drhoc, smoothing_width)

    ### regularlize the derivatives so we don't get oscillatory behavior due to numerical precision when there is no change with respect to rhoc
    ### only filter placed where we've touched both dM and dI to account for numerical error
    spurious = (np.abs(dlnI_drhoc*rhoc)<flatten_thr) *(np.abs(dlnM_drhoc*rhoc)<flatten_thr)

    dlnI_drhoc[spurious] = 0
    dlnM_drhoc[spurious] = 0

    ans = np.arctan2(dlnI_drhoc, dlnM_drhoc)
    ans[ans>np.pi/2] -= 2*np.pi ### wrap this around so that all the region where dlnM_drhoc < 0 is "contiguous"

    return ans, (spurious, dlnM_drhoc, dlnI_drhoc)

def abs_curvature(s, x, y, smoothing_width=None):
    """computes something like a smoothed curvature to identify interesting points in the M(s) -- dln[y(s)]/dln[x(s)] plane
    """
    ### compute curvature given this parametrization
    ans = gp.num_dfdx(s, x)*gp.num_dfdx(s, gp.num_dfdx(s, y))
    ans -= gp.num_dfdx(s, y)*gp.num_dfdx(s, gp.num_dfdx(s, x))
    ans /= (gp.num_dfdx(s, x)**2 + gp.num_dfdx(s, y)**2)**(3./2)

    ### take the absolute value of the curvature
    sgn = np.sign(ans) # remember the sign!
    ans = np.abs(ans)

    ### smooth the curvature estiamte
    if smoothing_width is not None:
        ans = smooth(s, ans, smoothing_width)

    return ans, sgn

def smooth(x, y, width):
    v = (width)**2
    ans = np.empty_like(y)
    inds = np.arange(len(x))
    for i, S in enumerate(x):
        weights = np.exp(-0.5*(S-x)**2/v) ### the basic Gaussian kernel
        weights /= np.sum(weights)
        ans[i] = np.sum(weights*y)
    return ans

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('eospath', type=str)
parser.add_argument("macropath", type=str)

parser.add_argument('--outpath', default=None,
    help='if specified, write to this file. Otherwise, print to stdout')

parser.add_argument("--eos-baryon-density-column", default="baryon_density", type=str)
parser.add_argument("--eos-sound-speed-column", default="cs2c2", type=str)
parser.add_argument('--energy-densityc2-column', default='energy_densityc2', type=str)
parser.add_argument('--pressurec2-column', default='pressurec2', type=str)
parser.add_argument('--eos-reference-column', default=[], type=str, action='append')

parser.add_argument("--macro-mass-column", default='M', type=str)
parser.add_argument("--macro-moi-column", default='I', type=str)
parser.add_argument("--macro-baryon-density-column", default='rhoc', type=str)
parser.add_argument("--macro-reference-column", default=[], action='append', type=str,
    help='Columns for which we report the values at identified points. Can be used to identify different stellar models. \
For example, the central baryon density (rhoc) may be easier to connect to the EoS than just the mass and/or MoI')

parser.add_argument('--flatten-thr', default=0.0, type=float,
    help='the threshold on |dlnX/dlnrho| below which we set this to zero')
parser.add_argument('--smoothing-width', default=None, type=float,
    help='the std of a Gaussian kernel used to smooth our estimate of the absolute curvature. \
The kernel is defined over log(rhoc), and 0.02 seems to work well.')
parser.add_argument('--diff-thr', type=float, default=0.0,
    help='a threshold on how big the "dip" in arctan(dlnI/dlnM) must be for us to record the possible phase transition. \
This is useful for removing small numerical noise (likely from the somewhat "coarse grained" TOV solutions)')
parser.add_argument('--cs2c2-cofactor', type=float, default=1.0,
    help='a threshold on how big the ratio of sound speeds can be between the local minimum in arctan(dlnI/dlnM) and the preceeding running maximum in cs2c2. \
There are cases in which this helps reject things that stall the final collapse to a BH but do not look like obvious "classic" phase transitions in the sound speed.')

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-V', '--Verbose', default=False, action='store_true')

parser.add_argument('-p', '--plot', default=False, action='store_true')
parser.add_argument('--figtype', default=[], type=str, action='append')

parser.add_argument('-o', '--output-dir', default='.', type=str)
parser.add_argument('-t', '--tag', default='', type=str)

args = parser.parse_args()

if args.tag:
    args.tag = "_"+args.tag

if not args.figtype:
    args.figtype.append('png')

args.verbose |= args.Verbose

#-------------------------------------------------

if args.verbose:
    print('loading eos data from: '+args.eospath)
eos_data, eos_cols = utils.load(args.eospath, [args.eos_baryon_density_column, args.eos_sound_speed_column, args.pressurec2_column, args.energy_densityc2_column]+args.eos_reference_column)
baryon_density = eos_data[:,0]
eos_data = eos_data[np.argsort(baryon_density)] ### sort so we increase in baryon density

# separate things in a way that's convenient
baryon_density = eos_data[:,0]
cs2c2 = eos_data[:,1]
pressurec2 = eos_data[:,2]
energy_densityc2 = eos_data[:,3]

#------------------------

if args.verbose:
    print('loading macro data from: '+args.macropath)
macro_data, macro_cols = utils.load(args.macropath, [args.macro_mass_column, args.macro_moi_column, args.macro_baryon_density_column]+args.macro_reference_column)

### make sure we order the result by increasing rhoc (which should be the default, but we need to check)
rhoc = macro_data[:,2]
macro_data = macro_data[np.argsort(rhoc)]

# separate things in a way that's convenient
M = macro_data[:,0]
I = macro_data[:,1]
rhoc = macro_data[:,2]

#------------------------

if args.verbose:
    print('extracting features of possible phase transitions')
params, names = identify_phase_transitions(
    rhoc,
    M,
    I,
    baryon_density,
    cs2c2,
    pressurec2,
    macro_data,
    macro_cols,
    eos_data,
    eos_cols,
    flatten_thr=args.flatten_thr,
    smoothing_width=args.smoothing_width,
    diff_thr=args.diff_thr,
    cs2c2_cofactor=args.cs2c2_cofactor,
    verbose=args.Verbose,
)

if args.outpath is not None:
    if args.verbose:
        print('saving parameters of %d identified phase transitions to: %s'%(len(params), args.outpath))
else:
    args.outpath = sys.stdout
np.savetxt(args.outpath, params, delimiter=',', comments='', header=','.join(names))

#-------------------------------------------------

if args.plot: ### make a big ol' plot
    if args.verbose:
        print('plotting the identified phase transitions')

    TEMPLATES = [
        (MAX_CS2C2_TEMPLATE, 'm'),
#        (MAX_K_TEMPLATE, 'c'),
        (MIN_CS2C2_TEMPLATE, 'r'),
        (MIN_ARCTAN_DLNI_DLNM_TEMPLATE, 'b'),
        (MAX_DCS_DP_TEMPLATE, 'c'),
    ]

    ### things that will be plotted against rhoc

    ### compute basis of indicator variable
    arctan_dlnI_dlnM, (spurious, dlnM_drhoc, dlnI_drhoc) = arctan_transform(rhoc, M, I, flatten_thr=args.flatten_thr, smoothing_width=args.smoothing_width)

    macro_y = [
        ('M', r'$M\ [M_\odot]$', M, 'linear'),
        ('dlnM_dlnrhoc', r'$d\ln M/d\ln \rho_c$', dlnM_drhoc*rhoc, 'linear'),
        ('I', r'$I\ [\mathrm{some units}]$', I, 'linear'),
        ('dlnI_dlnrhoc', r'$d\ln I/d\ln \rho_c$', dlnI_drhoc*rhoc, 'linear'),
        ('arctan_dlnI_dlnM', r'$\mathrm{arctan}(d\ln I/d\ln M)$', arctan_dlnI_dlnM, 'linear'),
    ]

    ### things that will be plotted against baryon_density
    pressurec2 = eos_data[:,eos_cols.index(args.pressurec2_column)]

    dcs2c2_deps = gp.num_dfdx(energy_densityc2, cs2c2)
    dcs2c2_dp = gp.num_dfdx(pressurec2, cs2c2)

    d2cs2c2_dp2 = gp.num_dfdx(pressurec2, dcs2c2_dp) * pressurec2**2

    d2cs2c2_deps2 = gp.num_dfdx(energy_densityc2, dcs2c2_deps) * energy_densityc2**2
    d2cs2c2_dlneps2 = gp.num_dfdx(energy_densityc2, dcs2c2_deps * energy_densityc2) * energy_densityc2

    micro_y = [
        ('pressurec2', '$p/c^2\ [\mathrm{g}/\mathrm{cm}^2]$', pressurec2, 'log', (1e11, 1e16)),
        ('cs2c2', '$c_s^2/c^2$', cs2c2, 'log', (1e-3, 1.0)),
#        ('d(cs2c2_d(lnenergy_densityc2)', '$dc_s^2/d\ln\epsilon$', dcs2c2_deps * energy_densityc2, 'linear', (-2, +2)),
#        ('d(cs2c2_d(lnenergy_densityc2)', '$dc_s^2/d\ln p $', dcs2c2_dp * pressurec2, 'linear', (-2, +2)),
        ('d(cs2c2_d(lnenergy_densityc2)', '$dc_s^2/d\epsilon$', dcs2c2_deps, 'linear', (-1e-14, +1e-14)),
        ('d(cs2c2_d(lnenergy_densityc2)', '$dc_s^2/dp $', dcs2c2_dp, 'linear', (-1e-13, +1e-13)),
        ('does not matter', r'$\left|d^2c_s^2/d\epsilon^2\right|\epsilon^2$', np.abs(d2cs2c2_deps2), 'log', (1e-2, 1e+2)), 
        ('not applicable', r'$\left|d^2c_s^2/dp^2\right|p^2$', np.abs(d2cs2c2_dp2), 'log', (1e-2, 1e+1)),
#        ('d(d(cs2c2)_d(lnenergy_densityc2))_d(lnenergy_densityc2)', r'$\left|d^2c_s^2/d\ln\epsilon^2\right|$', np.abs(d2cs2c2_dlneps2), 'log', (1e-2, 1e+1)),
#        ('does not matter', r'$\left(d^2c_s^2/d\epsilon^2\right)\epsilon^2$', d2cs2c2_deps2, 'linear', None), 
#        ('d(d(cs2c2)_d(lnenergy_densityc2))_d(lnenergy_densityc2)', '$d^2c_s^2/d\ln\epsilon^2$', d2cs2c2_dlneps2, 'linear', None),
    ]

    ### actually make the figure
    Nrow = max(len(macro_y), len(micro_y))

    fig = plt.figure(figsize=(10, 3*Nrow))

    line_kwargs = dict(linestyle='solid', marker='o', markersize=2, color='k', alpha=0.75)
    marker_kwargs = dict(marker='o', markerfacecolor='none', linestyle='none', markersize=4, markeredgewidth=1)

    ### plot the things that go vs rhoc
    row = 1

    for name, label, vec, scale in macro_y:
        ax = plt.plt.subplot(Nrow, 2, row)

        ### plot the main curve
        ax.plot(rhoc, vec, **line_kwargs)

        ### decorate
        ax.set_ylabel(label)
        plt.setp(ax.get_xticklabels(), visible=False)

        ax.set_xscale('log')
        ax.set_xlim(xmin=2.0e14, xmax=4.0e15) ### FIXME: don't hard-code this?

        ax.set_yscale(scale)

        ax.grid(True, which='both')

        # annotate points corresponding to params!
        ylim = ax.get_ylim()
        for tmp, color in TEMPLATES:
            start = params[:,names.index(tmp%args.macro_baryon_density_column)] ### NOTE: using the macro value here instead of the eos value
            y = np.interp(start, rhoc, vec)
            ax.plot(start, y, markeredgecolor=color, **marker_kwargs)
            for X in start:
                ax.plot([X]*2, ylim, color=color)

        # shade unstable regions
        if (name == 'dlnM_dlnrhoc') and (ylim[0] < 0):
            xlim = ax.get_xlim()
            ax.fill_between(xlim, [ylim[0]]*2, [0]*2, color='grey', alpha=0.25)
            ax.set_xlim(xlim)

        elif (name == 'arctan_dlnI_dlnM') and (ylim[0] < -np.pi/2):
            xlim = ax.get_xlim()
            ax.fill_between(xlim, [ylim[0]]*2, [-np.pi/2]*2, color='grey', alpha=0.25)
            ax.set_xlim(xlim)
            
        ax.set_ylim(ylim)

        # increment the row number
        row += 2 

    ### finish decoration
    ax.set_xlabel(r'$\rho_c\ [\mathrm{g}/\mathrm{cm}^3]$')
    plt.setp(ax.get_xticklabels(), visible=True)

    ### plot the things that go vs baryon_density
    row = 2
    for name, label, vec, scale, ylim in micro_y:
        ax = plt.plt.subplot(Nrow, 2, row)

        ### plot the main curve
        ax.plot(baryon_density, vec, **line_kwargs)

        ### decorate
        ax.set_ylabel(label)
        plt.setp(ax.get_xticklabels(), visible=False)

        ax.set_xscale('log')
        ax.set_xlim(xmin=3e13, xmax=1e16) ### FIXME: don't hard-code this?

        ax.set_yscale(scale)
        ax.yaxis.tick_right()
        ax.yaxis.set_label_position('right')

        ax.grid(True, which='both')

        # annotate points corresponding to params!
        if ylim is None:
            ylim = ax.get_ylim()

        for tmp, color in TEMPLATES:
            start = params[:,names.index(tmp%args.eos_baryon_density_column)] ### NOTE: using the eos value here instead of the macro value
            y = np.interp(start, baryon_density, vec)
            ax.plot(start, y, markeredgecolor=color, **marker_kwargs)
            for X in start:
                ax.plot([X]*2, ylim, color=color)

        ax.set_ylim(ylim)

        # increment the row number
        row += 2

    ### finish decoration
    ax.set_xlabel(r'$\rho_c\ [\mathrm{g}/\mathrm{cm}^3]$')
    plt.setp(ax.get_xticklabels(), visible=True)

    plt.plt.subplots_adjust(top=0.98, bottom=0.05, left=0.10, right=0.90, hspace=0.02, wspace=0.02)
    
    ### save
    plt.save('extract-moi-features%s'%args.tag, fig, figtypes=args.figtype, directory=args.output_dir, verbose=args.verbose)
    plt.close(fig)
