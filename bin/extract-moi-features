#!/usr/bin/env python

"""a script that processes macroscipic relations between the mass and moment of inertia (MoI) in order to identify and characterize phase transitoins"""
__author__ = "reed.essick@gmail.com"

#-------------------------------------------------

import os
import sys
import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import gaussianprocess as gp
from universality import plot as plt

#-------------------------------------------------

MAX_CS2C2_TEMPLATE = 'max_cs2c2_%s'
#MAX_K_TEMPLATE = 'max_k_%s'
MIN_CS2C2_TEMPLATE = 'min_cs2c2_%s'
MIN_ARCTAN_DLNI_DLNM_TEMPLATE = 'min_arctan_dlnI_dlnM_%s'

def identify_phase_transitions(
        rhoc,
        M,
        I,
        baryon_density,
        cs2c2,
        macro_data,
        macro_cols,
        eos_data,
        eos_cols,
        flatten_thr=0.0,
        smoothing_width=None,
        diff_thr=0.0,
        verbose=False,
    ):
    """
    looks for specific behavior in arctan(dlnI/dlnM) that seems to correspond to phase transitions.
    returns the corresponding values from data along with names based on cols
    """
    names = ['transition']
    for tmp in [
            MAX_CS2C2_TEMPLATE,
#            MAX_K_TEMPLATE,
            MIN_CS2C2_TEMPLATE,
            MIN_ARCTAN_DLNI_DLNM_TEMPLATE,
        ]:
        names += [tmp%col for col in macro_cols]
        names += [tmp%col for col in eos_cols]
    params = []

    ### compute the absolute value of the curvature, which we use as an indicator variable
    arctan_dlnI_dlnM, (spurious, dlnM_drhoc, dlnI_drhoc) = arctan_transform(rhoc, M, I, flatten_thr=flatten_thr, smoothing_width=smoothing_width)

    ### find the possible end points as local minima of arctan_dlnI_dlnM
#    ends = list(find_minima(arctan_dlnI_dlnM)[::-1]) ### reverse so the ones with largest rhoc are first
    ends = list(find_inclusive_minima(arctan_dlnI_dlnM)[::-1]) ### reverse so the ones with largest rhoc are first

    ### discard any local minima that are in the final unstable branch
    while len(ends):
        end = ends.pop(0)
        if np.any(dlnM_drhoc[end:] > 0): ### not part of the 'final unstable branch'
            ends.insert(0, end)
            break

    if ends: ### we have something to do
#        k, s = abs_curvature(np.log(rhoc), M, arctan_dlnI_dlnM, smoothing_width=smoothing_width)
#
#        max_k = np.array([ind for ind in find_maxima(k) if s[ind] < 0])
#        max_k_rhoc = rhoc[max_k]

        print('WARING! requiring max, min cs2c2 to be on a stable branch causes us to drop things that are below when we started solving the TOV equations!')
        print('maybe just require that max, min are either stable or below the lowest rhoc available?')

        min_cs2c2 = find_inclusive_minima(cs2c2)
        min_cs2c2 = [ind for ind in min_cs2c2 if (baryon_density[ind] < rhoc[0]) or (np.interp(baryon_density[ind], rhoc, dlnM_drhoc) > 0)] ### only retain points on stable branches
        min_cs2c2 = np.array(min_cs2c2)
        min_cs2c2_baryon_density = baryon_density[min_cs2c2]

        max_cs2c2 = find_maxima(cs2c2)
        max_cs2c2 = [ind for ind in max_cs2c2 if (baryon_density[ind] < rhoc[0]) or (np.interp(baryon_density[ind], rhoc, dlnM_drhoc) > 0)] ### only retain points on stable branches
        max_cs2c2 = np.array(max_cs2c2)
        max_cs2c2_baryon_density = baryon_density[max_cs2c2]

        # iterate through and grab the following associated with each "end"
        Neos = len(eos_cols)
        Nmac = len(macro_cols)
        last_r = +np.infty ### logic to avoid overlapping phase transitions
        group = []
        for end in ends:
            r = rhoc[end]
            datum = []

            if verbose:
                print('    processing end at rhoc=%.6e'%r)

            ### max sound speed preceeding "end"
            try:
                ind = find_preceeding(r, max_cs2c2_baryon_density, max_cs2c2)
            except RuntimeError:
                if verbose:
                    print('    WARNING! could not find preceeding maximum in cs2c2')
                continue

            min_r = baryon_density[ind] ### expect max(cs2c2) to be the smallest density (required if we're to keep this possible transition)
            max_cs2c2_arctan = np.interp(min_r, rhoc, arctan_dlnI_dlnM)

            if (dlnM_drhoc[end] > 0) and (np.max(np.abs(arctan_dlnI_dlnM[(min_r<=rhoc)*(rhoc<=r)] - arctan_dlnI_dlnM[end])) < diff_thr): ### does not pass our basic selection cut for being "big enough". Note that we add an exception if we're on an unstable branch (that's gotta be a strong phase transition...)
                if verbose:
                    print('    WARNING! difference in arctan_dlnI_dlnM is smaller than diff_thr; skipping this possible transition')
                continue

            datum += [np.interp(min_r, rhoc, macro_data[:,i]) for i in range(Nmac)]
            datum += list(eos_data[ind])

            ### maximum of the curvature associated preceeding "end"
            '''
            try:
                ind = find_preceeding(r, max_k_rhoc, max_k)
            except RuntimeError:
                if verbose:
                    print('    WARNING! coult not find preceeding maximum in curvature')
                continue

            datum += list(macro_data[ind])
            datum += [np.interp(rhoc[ind], baryon_density, eos_data[:,i]) for i in range(Neos)]

            if rhoc[ind] < min_r: ### bad ordering
                if verbose:
                    print('    WARNING! max(k) occurs earlier than max(cs2c2); rejecting this possible transition')
                continue
            '''

            ### min sound speed preceeding "end"
            try:
                ind = find_preceeding(r, min_cs2c2_baryon_density, min_cs2c2)
            except RuntimeError:
                if verbose:
                    print('    WARNING! coult not find preceeding minimum in cs2c2')
                continue

            min_cs2c2_arctan = np.interp(baryon_density[ind], rhoc, arctan_dlnI_dlnM)
            if max(max_cs2c2_arctan, min_cs2c2_arctan) < arctan_dlnI_dlnM[end]: ### both are smaller, so we're kinda on an "upward sweep" that typically doesn't correspond to the behavior we want
                if verbose:
                    print('    WARNING! arctan(dlnI/dlnM) at max_cs2c2 and min_cs2c2 is less than at the local minimum; skipping this possible transition')
                continue

            datum += [np.interp(baryon_density[ind], rhoc, macro_data[:,i]) for i in range(Nmac)]
            datum += list(eos_data[ind])
 
            if baryon_density[ind] < min_r:
                if verbose:
                    print('    WARNING: min(cs2c2) occurs earlier than max(cs2c2); rejecting this possible transition')
                continue

            ### parameters at "end"
            ind = end
            datum += list(data[end])
            datum += [np.interp(r, baryon_density, eos_data[:,i]) for i in range(Neos)]

            ### figure out if there is any overlap, keep the one with the minimum dlnI_drhoc[end]
            if len(group) and (r < last_r): ### we already have a group and this would *not* overlap with something we've already declared a phase transition, so figure out which is best and add it
                group.sort(key=lambda x:x[0]) ### sort so the smallest dlnI_drhoc is first
                params.append(group[0][1]) ### append the datum
                group = [] ### start a new group
            group.append((arctan_dlnI_dlnM[end], datum))

            last_r = min_r ### update this so we remember the extent of the current phase transition (avoid overlaps with the next one)

    if group: ### add the last identified transition
        group.sort(key=lambda x:x[0])
        params.append(group[0][1])

    params = [[ind]+thing for ind, thing in enumerate(params)] ### include a transition number for reference

    if not len(params):
        params = np.empty((0,len(names)), dtype=float)

    else:
        params = np.array(params, dtype=float)

    return params, names

def find_preceeding(x_ref, x, y):
    found = x <= x_ref
    if np.sum(found):
        return y[found][-1]
    else:
        raise RuntimeError('no preceeding value found!')

def find_maxima(x):
    """find indecies of strict local maxima"""
    return find_minima(-np.array(x))

def find_minima(x):
    """find indecies of strict local minima"""
    mins = []
    old = +np.infty
    for i in range(len(x)-1):
        new = x[i]
        if (old > new) and (new < x[i+1]):
            mins.append(i)
        old = new
    if x[i+1] > x[i]:
        mins.append(i+1)
    return mins

def find_inclusive_minima(x):
    """find indecies of local minima, including cases when the value does not change from one sample to the next"""
    mins = []
    old = +np.infty
    for i in range(len(x)-1):
        new = x[i]
        if (old >= new) and (new <= x[i+1]):
            mins.append(i)
        old = new
    if x[i+1] > x[i]:
        mins.append(i+1)
    return mins

def arctan_transform(rhoc, M, I, flatten_thr=0., smoothing_width=None):
    """compute the special arctan function we use to feed into our feature identification function
    """
    dlnI_drhoc = gp.num_dfdx(rhoc, I) / I
    dlnM_drhoc = gp.num_dfdx(rhoc, M) / M

    if smoothing_width:
        dlnI_drhoc = smooth(np.log(rhoc), dlnI_drhoc, smoothing_width)
        dlnM_drhoc = smooth(np.log(rhoc), dlnM_drhoc, smoothing_width)

    ### regularlize the derivatives so we don't get oscillatory behavior due to numerical precision when there is no change with respect to rhoc
    ### only filter placed where we've touched both dM and dI to account for numerical error
    spurious = (np.abs(dlnI_drhoc*rhoc)<flatten_thr) *(np.abs(dlnM_drhoc*rhoc)<flatten_thr)

    dlnI_drhoc[spurious] = 0
    dlnM_drhoc[spurious] = 0

    ans = np.arctan2(dlnI_drhoc, dlnM_drhoc)
    ans[ans>np.pi/2] -= 2*np.pi ### wrap this around so that all the region where dlnM_drhoc < 0 is "contiguous"

    return ans, (spurious, dlnM_drhoc, dlnI_drhoc)

def abs_curvature(s, x, y, smoothing_width=None):
    """computes something like a smoothed curvature to identify interesting points in the M(s) -- dln[y(s)]/dln[x(s)] plane
    """
    ### compute curvature given this parametrization
    ans = gp.num_dfdx(s, x)*gp.num_dfdx(s, gp.num_dfdx(s, y))
    ans -= gp.num_dfdx(s, y)*gp.num_dfdx(s, gp.num_dfdx(s, x))
    ans /= (gp.num_dfdx(s, x)**2 + gp.num_dfdx(s, y)**2)**(3./2)

    ### take the absolute value of the curvature
    sgn = np.sign(ans) # remember the sign!
    ans = np.abs(ans)

    ### smooth the curvature estiamte
    if smoothing_width is not None:
        ans = smooth(s, ans, smoothing_width)

    return ans, sgn

def smooth(x, y, width):
    v = (width)**2
    ans = np.empty_like(y)
    inds = np.arange(len(x))
    for i, S in enumerate(x):
        weights = np.exp(-0.5*(S-x)**2/v) ### the basic Gaussian kernel
        weights /= np.sum(weights)
        ans[i] = np.sum(weights*y)
    return ans

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('eospath', type=str)
parser.add_argument("macropath", type=str)

parser.add_argument('--outpath', default=None,
    help='if specified, write to this file. Otherwise, print to stdout')

parser.add_argument("--eos-baryon-density-column", default="baryon_density", type=str)
parser.add_argument("--eos-sound-speed-column", default="cs2c2", type=str)
parser.add_argument('--eos-reference-column', default=[], type=str, action='append')

parser.add_argument("--macro-mass-column", default='M', type=str)
parser.add_argument("--macro-moi-column", default='I', type=str)
parser.add_argument("--macro-baryon-density-column", default='rhoc', type=str)
parser.add_argument("--macro-reference-column", default=[], action='append', type=str,
    help='Columns for which we report the values at identified points. Can be used to identify different stellar models. \
For example, the central baryon density (rhoc) may be easier to connect to the EoS than just the mass and/or MoI')

parser.add_argument('--flatten-thr', default=2e-2, type=float,
    help='the threshold on |dlnX/dlnrho| below which we set this to zero')
parser.add_argument('--smoothing-width', default=0.01, type=float,
    help='the std of a Gaussian kernel used to smooth our estimate of the absolute curvature. \
The kernel is defined over log(rhoc), and 0.02 seems to work well.')
parser.add_argument('--diff-thr', type=float, default=0.0)

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-V', '--Verbose', default=False, action='store_true')

parser.add_argument('-p', '--plot', default=False, action='store_true')
parser.add_argument('--figtype', default=[], type=str, action='append')

parser.add_argument('-o', '--output-dir', default='.', type=str)
parser.add_argument('-t', '--tag', default='', type=str)

args = parser.parse_args()

if args.tag:
    args.tag = "_"+args.tag

if not args.figtype:
    args.figtype.append('png')

args.verbose |= args.Verbose

#-------------------------------------------------

if args.verbose:
    print('loading eos data from: '+args.eospath)
eos_data, eos_cols = utils.load(args.eospath, [args.eos_baryon_density_column, args.eos_sound_speed_column]+args.eos_reference_column)
baryon_density = eos_data[:,0]
cs2c2 = eos_data[:,1]

#------------------------

if args.verbose:
    print('loading macro data from: '+args.macropath)
macro_data, macro_cols = utils.load(args.macropath, [args.macro_mass_column, args.macro_moi_column, args.macro_baryon_density_column]+args.macro_reference_column)

### make sure we order the result by increasing rhoc (which should be the default, but we need to check)
rhoc = macro_data[:,2]
data = macro_data[np.argsort(rhoc)]

# separate things in a way that's convenient
M = macro_data[:,0]
I = macro_data[:,1]
rhoc = macro_data[:,2]

#------------------------

if args.verbose:
    print('extracting features of possible phase transitions')
params, names = identify_phase_transitions(
    rhoc,
    M,
    I,
    baryon_density,
    cs2c2,
    macro_data,
    macro_cols,
    eos_data,
    eos_cols,
    flatten_thr=args.flatten_thr,
    smoothing_width=args.smoothing_width,
    diff_thr=args.diff_thr,
    verbose=args.Verbose,
)

if args.outpath is not None:
    if args.verbose:
        print('saving parameters of %d identified phase transitions to: %s'%(len(params), args.outpath))
else:
    args.outpath = sys.stdout
np.savetxt(args.outpath, params, delimiter=',', comments='', header=','.join(names))

#-------------------------------------------------

if args.plot:
    if args.verbose:
        print('building basic sanity checking and reference plot')

    ### compute basis of indicator variable
    arctan_dlnI_dlnM, (spurious, dlnM_drhoc, dlnI_drhoc) = arctan_transform(rhoc, M, I, flatten_thr=args.flatten_thr, smoothing_width=args.smoothing_width)

    fig = plt.figure()
    ax = plt.plt.subplot(2,2,1)
    AX = plt.plt.subplot(2,2,3)

    xa = plt.plt.subplot(2,2,2)
    XA = plt.plt.subplot(2,2,4)

    # plot
    kwargs = dict(linestyle='none', marker='.', markersize=2, color='k')

    ax.plot(rhoc, M)
    ax.plot(rhoc[spurious], M[spurious], **kwargs)

    AX.plot(rhoc, dlnM_drhoc*rhoc)
    AX.plot(rhoc[spurious], dlnM_drhoc[spurious]*rhoc[spurious], **kwargs)

    xa.plot(rhoc, I)
    xa.plot(rhoc[spurious], I[spurious], **kwargs)

    XA.plot(rhoc, dlnI_drhoc*rhoc)
    XA.plot(rhoc[spurious], dlnI_drhoc[spurious]*rhoc[spurious], **kwargs)

    for _ in [ax, AX, xa, XA]:
        _.set_xscale("log")
        _.set_xlim(xmin=1.5e14, xmax=4e15)
        _.grid(True, which='both')

    ax.set_ylabel('$M\ [M_\odot]$')
    AX.set_ylabel(r'$d\ln M/d\ln\rho_c$')

    xa.set_ylabel('$I$ some units')
    XA.set_ylabel(r'$d\ln I/d\ln\rho_c$')

    for _ in [xa, XA]:
        _.yaxis.tick_right()
        _.yaxis.set_label_position('right')

    for _ in [ax, xa]:
        plt.setp(_.get_xticklabels(), visible=False)

    for _ in [AX, XA]:
        _.set_xlabel(r'$\rho_c\ [\mathrm{g}/\mathrm{cm}^3]$')

    plt.plt.subplots_adjust(hspace=0.02, wspace=0.02)

    ### save
    plt.save('extract-moi-features-reference%s'%args.tag, fig, figtypes=args.figtype, directory=args.output_dir, verbose=args.verbose)
    plt.close(fig)

    #--------------------

    if args.verbose:
        print('plotting the identified phase transitions')

    fig = plt.figure()
    ax = plt.plt.subplot(2,2,1)
    AX = plt.plt.subplot(2,2,3)

    xa = plt.plt.subplot(2,2,2)
    XA = plt.plt.subplot(2,2,4)

    ymin = -3*np.pi/2. ### bounds the range of arctan
    ymax = +np.pi/2.

    # plot the main curve
    kwargs = dict(linestyle='none', marker='.', markersize=2, color='y')

    ax.plot(M, arctan_dlnI_dlnM, color='k')
    ax.plot(M[spurious], arctan_dlnI_dlnM[spurious], **kwargs)

    AX_y = gp.num_dfdx(M, arctan_dlnI_dlnM)
    AX.plot(M, AX_y, color='k')
    AX.plot(M[spurious], AX_y[spurious], **kwargs)

    xa.plot(rhoc, arctan_dlnI_dlnM, color='k')
    xa.plot(rhoc[spurious], arctan_dlnI_dlnM[spurious], **kwargs)

    XA_y, _ = abs_curvature(np.log(rhoc), M, arctan_dlnI_dlnM, smoothing_width=args.smoothing_width)
    XA.plot(rhoc, XA_y, color='k')
    XA.plot(rhoc[spurious], XA_y[spurious], **kwargs)

    # annotate points corresponding to params!
    kwargs = dict(marker='o', markerfacecolor='none', linestyle='none', markersize=4, markeredgewidth=1)

    for tmp, color in [
            (MAX_CS2C2_TEMPLATE, 'm'),
#            (MAX_K_TEMPLATE, 'c'),
            (MIN_CS2C2_TEMPLATE, 'r'),
            (MIN_ARCTAN_DLNI_DLNM_TEMPLATE, 'b'),
        ]:
        start = params[:,names.index(tmp%args.macro_baryon_density_column)]
        y = np.interp(start, rhoc, arctan_dlnI_dlnM)
        xa.plot(start, y, markeredgecolor=color, **kwargs)

        start_M = params[:,names.index(tmp%args.macro_mass_column)]
        ax.plot(start_M, y, markeredgecolor=color, **kwargs)

        y = np.interp(start, rhoc, XA_y)
        XA.plot(start, y, markeredgecolor=color, **kwargs)

        y = np.interp(start, rhoc, AX_y)
        AX.plot(start_M, y, markeredgecolor=color, **kwargs)

    # shade the regions that corresponds to negative dM/drhoc
    ax.set_xscale('linear')
    AX.set_xscale(ax.get_xscale())

    xa.set_xscale('log')
    XA.set_xscale(xa.get_xscale())

    xlim = ax.get_xlim()
    ax.fill_between(xlim, [ymin]*2, [-np.pi/2]*2, color='grey', alpha=0.5)
    ax.fill_between(xlim, [ymax]*2, [+np.pi/2]*2, color='grey', alpha=0.5)
    ax.set_xlim(xlim)

    xlim = xa.get_xlim()
    xa.fill_between(xlim, [ymin]*2, [-np.pi/2]*2, color='grey', alpha=0.5)
    xa.fill_between(xlim, [ymax]*2, [+np.pi/2]*2, color='grey', alpha=0.5)
    xa.set_xlim(xlim)

    # decroate
    ax.set_ylim(ymin=ymin, ymax=ymax)

    ax.set_xlabel(r'$M\ [M_\odot]$')
    ax.set_ylabel(r'$\mathrm{arctan}\left(\left.d\ln I\right/d\ln M\right)$')

    ax.grid(True, which='both')

    AX.set_xlim(ax.get_xlim())

    AX.set_ylabel(r'$d\left(\mathrm{arctan}\left(\left.d\ln I\right/d\ln M\right)\right)/dM$')
    AX.set_xlabel(ax.get_xlabel())

    AX.grid(True, which='both')

    xa.set_xlim(xmin=1.5e14, xmax=4e15)
    xa.set_ylim(ymin=ymin, ymax=ymax)

    xa.set_xlabel(r'$\rho_c\ [\mathrm{g}/\mathrm{cm}^3]$')
    xa.set_ylabel(r'$\mathrm{arctan}\left(\left.d\ln I\right/d\ln M\right)$')

    xa.grid(True, which='both')

    XA.set_xlim(xa.get_xlim())
    XA.set_yscale('log')
    ylim = XA.get_ylim()
    XA.set_ylim(ymin=max(1e-10, ylim[0]), ymax=min(1e+15, ylim[1]))

    XA.set_ylabel(r'$\kappa\left[\ln\rho_c, M, \mathrm{arctan}(d\ln I/d\ln M)\right]$')
    XA.set_xlabel(xa.get_xlabel())

    XA.grid(True, which='both')

    plt.setp(ax.get_xticklabels(), visible=False)
    ax.set_xlabel('')
    plt.setp(xa.get_xticklabels(), visible=False)
    xa.set_xlabel('')

    xa.yaxis.tick_right()
    xa.yaxis.set_label_position('right')

    XA.yaxis.tick_right()
    XA.yaxis.set_label_position('right')

    plt.plt.subplots_adjust(hspace=0.02, wspace=0.02)
    
    ### save
    plt.save('extract-moi-features%s'%args.tag, fig, figtypes=args.figtype, directory=args.output_dir, verbose=args.verbose)
    plt.close(fig)
