#!/usr/bin/env python

__doc__ = "generate plots of processes from CSV files which refer to EOS tables (other csv files)"
__usage__ = "overlay-plot_process [--options] label1,samples1.csv label2,samples2.csv y-column x-column x-min x-max samples1.csv samples2.csv"
__author__ = "reed.essick@ligo.org"

#-------------------------------------------------

import os
import numpy as np

from optparse import OptionParser

### non-standard libraries
from universality import utils
from universality import plot

#-------------------------------------------------

def quantile(x, quantiles, weights=None):
    if weights is None:
        return np.percentile(x, np.array(quantiles)*100)

    else:
        order = x.argsort()
        x = x[order]
        csum = np.cumsum(weights[order])
        return np.array([x[[csum<=q]][-1] for q in quantiles])

#-------------------------------------------------

parser = OptionParser(usage=__usage__, description=__doc__)

parser.add_option('-v', '--verbose', default=False, action='store_true')
parser.add_option('-V', '--Verbose', default=False, action='store_true')

parser.add_option('', '--num-points', default=101, type='int',
    help='the number of interpolation points used when plotting')

parser.add_option('', '--logcolumn', default=[], type='string', action='append',
    help='plot the corresponding column on a log scale. \
Can be repeated to specify multiple columns. \
DEFAULT=[]')

parser.add_option('', '--eos1-column', default='eos', type='string')
parser.add_option('', '--eos1-dir', default='.', type='string')
parser.add_option('', '--eos1-basename', default='draw_foo-%d.csv', type='string',
    help='a string into which the EOS number can be substituted when building filenames. \
DEFAULT=draw_foo-%d.csv')

parser.add_option('', '--eos2-column', default='eos', type='string')
parser.add_option('', '--eos2-dir', default='.', type='string')
parser.add_option('', '--eos2-basename', default='draw_foo-%d.csv', type='string',
    help='a string into which the EOS number can be substituted when building filenames. \
DEFAULT=draw_foo-%d.csv')

parser.add_option('--max-num-samples1', default=utils.DEFAULT_MAX_NUM_SAMPLES, type='int')
parser.add_option('', '--weight1-column', default=None, type='string',
    help='if provided, thie numerical values from this column will be used as weights in the KDE')
parser.add_option('', '--weight1-column-is-log', default=False, action='store_true',
    help='if supplied, interpret the values in weight_column as log(weight), meaning we exponentiate them before using them in the KDE')

parser.add_option('--max-num-samples2', default=utils.DEFAULT_MAX_NUM_SAMPLES, type='int')
parser.add_option('', '--weight2-column', default=None, type='string',
    help='if provided, thie numerical values from this column will be used as weights in the KDE')
parser.add_option('', '--weight2-column-is-log', default=False, action='store_true',
    help='if supplied, interpret the values in weight_column as log(weight), meaning we exponentiate them before using them in the KDE')

parser.add_option('', '--quantile', default=[], type='float', action='append',
    help='plot these quantiles. We plot the quantile specified along with 1-quantile. \
DEFAULT=[0.1]')
parser.add_option('', '--alpha', default=0.25, type='float', 
    help='DEFAULT=0.25')

parser.add_option('', '--color1', default=plot.DEFAULT_COLOR1, type='string',
    help='DEFAULT='+plot.DEFAULT_COLOR1)
parser.add_option('', '--color2', default=plot.DEFAULT_COLOR2, type='string',
    help='DEFAULT='+plot.DEFAULT_COLOR2)

parser.add_option('', '--ymin', default=None, type='float')
parser.add_option('', '--ymax', default=None, type='float')
parser.add_option('', '--res-ymin', default=None, type='float')
parser.add_option('', '--res-ymax', default=None, type='float')

parser.add_option('--x-label', default=None, type='string',
    help='override column name as the label')
parser.add_option('--y-label', default=None, type='string',
    help='override column name as the label')

parser.add_option('--reference', default=[], type='string', action='append',
    help='path to a reference EOS that will be plotted on top of the process. Can be repeated to specify multiple reference curves. \
The columns must be the same as those supplied in the input arguments. \
DEFAULT=[]')
parser.add_option('--reference-color', default=None, type='string')

parser.add_option('--residuals', default=False, action='store_true',
    help='if True, plot the residuals between the median of the process and the reference curves. Cannot be supplied simultanesoulsy with --ratios')
parser.add_option('--ratios', default=False, action='store_true',
    help='if supplied, plot the ratio of the values instead of the difference (--residuals). Cannot be supplied simulaneously with --residuals')

parser.add_option('--include-neff', default=False, action='store_true',
    help='include an estimate of the effective number of samples as a title')

parser.add_option('--figwidth', default=plot.DEFAULT_FIGWIDTH, type='float')
parser.add_option('--figheight', default=plot.DEFAULT_FIGHEIGHT, type='float')
parser.add_option('-o', '--output-dir', default='.', type='string')
parser.add_option('-t', '--tag', default='', type='string')
parser.add_option('--figtype', default=[], type='string', action='append')
parser.add_option('--dpi', default=plot.DEFAULT_DPI, type='float')

opts, args = parser.parse_args()
assert len(args)==6, 'please supply at least 6 input argument\n%s'%__usage__
inpath1, inpath2, ycolumn, xcolumn, xmin, xmax = args
label1, inpath1 = inpath1.split(',')
label2, inpath2 = inpath2.split(',')
xmax = float(xmax)
xmin = float(xmin)

if opts.residuals and opts.ratios:
    raise ValueError('please only supply either --residuals or --ratios')

if opts.tag:
    opts.tag = "_"+opts.tag

if not os.path.exists(opts.output_dir):
    os.makedirs(opts.output_dir)

if not opts.figtype:
    opts.figtype = plot.DEFAULT_FIGTYPES

if not opts.quantile:
    opts.quantile = [0.1]
opts.quantile.sort()

quantiles = []
for q in opts.quantile:
    quantiles += [q, (1-q)]

opts.verbose |= opts.Verbose

#-------------------------------------------------

if opts.verbose:
    print('reading samples for %s from: %s'%(label1, inpath1))
data1, _ = utils.load(inpath1, [opts.eos1_column], max_num_samples=opts.max_num_samples1)

if opts.weight1_column!=None:
    if opts.verbose:
        print('reading in non-trivial weights for %s from: %s'%(label1, inpath1))
    weights1, _ = utils.load(inpath1, [opts.weight1_column], max_num_samples=opts.max_num_samples1)
    weights1 = weights1.reshape((len(weights1)))

    if opts.weight1_column_is_log:
        weights1 = np.exp(weights1-np.max(weights1))
    weights1 /= np.sum(weights1)

else:
    N1 = len(data1)
    weights1 = np.ones(N1, dtype='float')/N1

### prune samples to get rid of vanishing weights
data1, weights1 = utils.prune(data1, [(-np.infty, +np.infty)], weights=weights1)
data1 = data1[:,0]
N1 = len(data1)

#---

if opts.verbose:
    print('reading samples for %s from: %s'%(label2, inpath2))
data2, _ = utils.load(inpath2, [opts.eos2_column], max_num_samples=opts.max_num_samples2)

if opts.weight2_column!=None:
    if opts.verbose:
        print('reading in non-trivial weights for %s from: %s'%(label2, inpath2))
    weights2, _ = utils.load(inpath2, [opts.weight2_column], max_num_samples=opts.max_num_samples2)
    weights2 = weights2.reshape((len(weights2)))

    if opts.weight2_column_is_log:
        weights2 = np.exp(weights2-np.max(weights2))
    weights2 /= np.sum(weights2)

else:
    N2 = len(data2)
    weights2 = np.ones(N2, dtype='float')/N2

### prune samples to get rid of vanishing weights
data2, weights2 = utils.prune(data2, [(-np.infty, +np.infty)], weights=weights2)
data2 = data2[:,0]
N2 = len(data2)

#-----------

if xcolumn in opts.logcolumn:
    x_test = np.logspace(np.log10(xmin), np.log10(xmax), opts.num_points)
else:
    x_test = np.linspace(xmin, xmax, opts.num_points)

if opts.verbose:
    print('computing confidence intervals for %s from %d samples'%(label1, len(data1)))
y_test = np.empty((N1, opts.num_points), dtype='float')
for i, (eos, weight) in enumerate(zip(data1, weights1)): ### iterate over samples and compute weighted moments
    path = os.path.join(opts.eos1_dir, opts.eos1_basename%eos)
    if opts.Verbose:
        print('    '+path)
    d, c = utils.load(path, [xcolumn, ycolumn])

    y_test[i] = np.interp(x_test, d[:,0], d[:,1])

### compute the quantiles
y1 = np.empty((len(quantiles), opts.num_points), dtype='float')
y1_median = np.empty_like(x_test, dtype='float')
for i in xrange(opts.num_points):
    y1[:,i] = quantile(y_test[:,i], quantiles, weights=weights1)     ### compute quantiles
    y1_median[i] = quantile(y_test[:,i], [0.5], weights=weights1)[0] ### compute median

#---

if opts.verbose:
    print('computing confidence intervals for %s from %d samples'%(label2, len(data2)))
y_test = np.empty((N2, opts.num_points), dtype='float')
for i, (eos, weight) in enumerate(zip(data2, weights2)): ### iterate over samples and compute weighted moments
    path = os.path.join(opts.eos2_dir, opts.eos2_basename%eos)
    if opts.Verbose:
        print('    '+path)
    d, c = utils.load(path, [xcolumn, ycolumn])

    y_test[i] = np.interp(x_test, d[:,0], d[:,1])

### compute the quantiles
y2 = np.empty((len(quantiles), opts.num_points), dtype='float')
y2_median = np.empty_like(x_test, dtype='float')
for i in xrange(opts.num_points):
    y2[:,i] = quantile(y_test[:,i], quantiles, weights=weights2)     ### compute quantiles
    y2_median[i] = quantile(y_test[:,i], [0.5], weights=weights2)[0] ### compute median

#-------------------------------------------------

reference = []
if opts.reference:
    for path in opts.reference:
        if opts.verbose:
            print('reading reference curve from: '+path)
        reference.append(utils.load(path, [xcolumn, ycolumn])[0]) ### just grab the data, not the column names

#-------------------------------------------------

if opts.verbose:
    print('plotting')

fig = plot.plt.figure(figsize=(opts.figwidth, opts.figheight))
if opts.residuals or opts.ratios:
    ax = fig.add_axes(plot.MAIN_AXES_POSITION)
    ax_res = fig.add_axes(plot.RESIDUAL_AXES_POSITION)
else:
    ax = fig.gca()

# plot data1
for i in xrange(len(opts.quantile)): ### fill between pairs of quantiles
    ax.fill_between(x_test, y1[2*i,:], y1[2*i+1,:], alpha=opts.alpha, color=opts.color1)
    if opts.residuals:
        ax_res.fill_between(x_test, y1[2*i,:]-y1_median, y1[2*i+1,:]-y1_median, alpha=opts.alpha, color=opts.color1)
    elif opts.ratios:
        ax_res.fill_between(x_test, y1[2*i,:]/y1_median, y1[2*i+1,:]/y1_median, alpha=opts.alpha, color=opts.color1)

ax.plot(x_test, y1_median, color=opts.color1, alpha=1.0) ### plot the median
if opts.residuals:
    ax_res.plot(x_test, np.zeros_like(x_test), color=opts.color1, alpha=0.5, linestyle='solid')
elif opts.ratios:
    ax_res.plot(x_test, np.ones_like(x_test), color=opts.color1, alpha=0.5, linestyle='solid')

# plot data2
for i in xrange(len(opts.quantile)): ### fill between pairs of quantiles
    ax.fill_between(x_test, y2[2*i,:], y2[2*i+1,:], alpha=opts.alpha, color=opts.color2)
    if opts.residuals:
        ax_res.fill_between(x_test, y2[2*i,:]-y2_median, y2[2*i+1,:]-y2_median, alpha=opts.alpha, color=opts.color2)
    elif opts.ratios:
        ax_res.fill_between(x_test, y2[2*i,:]/y2_median, y2[2*i+1,:]/y2_median, alpha=opts.alpha, color=opts.color2)

ax.plot(x_test, y2_median, color=opts.color2, alpha=1.0) ### plot the median
if opts.residuals:
    ax_res.plot(x_test, np.zeros_like(x_test), color=opts.color2, alpha=0.5, linestyle='dashed')
elif opts.ratios:
    ax_res.plot(x_test, np.ones_like(x_test), color=opts.color2, alpha=0.5, linestyle='dashed')

for curve in reference:
    x = curve[:,0]
    y = curve[:,1]
    if opts.reference_color:
        color = ax.plot(x, y, color=opts.reference_color)[0].get_color()
    else:
        color = ax.plot(x, y)[0].get_color()
    if opts.residuals:
        ax_res.plot(x, y-np.interp(x, x_test, y1_median), color=color, linestyle='solid', alpha=0.5)
        ax_res.plot(x, y-np.interp(x, x_test, y2_median), color=color, linestyle='dashed', alpha=0.5)
    elif opts.ratios:
        ax_res.plot(x, y/np.interp(x, x_test, y1_median), color=color, linestyle='solid', alpha=0.5)
        ax_res.plot(x, y/np.interp(x, x_test, y2_median), color=color, linestyle='dashed', alpha=0.5)

if xcolumn in opts.logcolumn:
    ax.set_xscale('log')

if ycolumn in opts.logcolumn:
    ax.set_yscale('log')
    if opts.ratios:
        ax_res.set_yscale('log')

ax.grid(True, which='both')
if opts.residuals or opts.ratios:
    ax_res.grid(True, which='both')

ax.set_xlim(xmin=xmin, xmax=xmax)
if opts.residuals or opts.ratios:
    ax_res.set_xscale(ax.get_xscale())
    ax_res.set_xlim(ax.get_xlim())

if opts.ymin!=None:
    ax.set_ylim(ymin=opts.ymin)
if opts.ymax!=None:
    ax.set_ylim(ymax=opts.ymax)

if opts.residuals or opts.ratios:
    if opts.res_ymin!=None:
        ax_res.set_ylim(ymin=opts.res_ymin)
    if opts.res_ymax!=None:
        ax_res.set_ylim(ymax=opts.res_ymax)

if opts.include_neff:
    fig.text(0.10, 0.96, label1+': $N_\mathrm{eff} = %.1f$'%utils.neff(weights1), color=opts.color1, ha='left', va='bottom')
    fig.text(0.95, 0.96, label2+': $N_\mathrm{eff} = %.1f$'%utils.neff(weights2), color=opts.color2, ha='right', va='bottom')

ax.set_ylabel(opts.y_label if opts.y_label is not None else ycolumn)
if opts.residuals or opts.ratios:
    plot.plt.setp(ax.get_xticklabels(), visible=False)
    ax_res.set_xlabel(opts.x_label if opts.x_label is not None else xcolumn)
    if opts.residuals:
        ax_res.set_ylabel('%s - median'%(opts.y_label if opts.y_label is not None else ycolumn))
    if opts.ratios:
        ax_res.set_ylabel('%s/median'%(opts.y_label if opts.y_label is not None else ycolumn))
else:
    ax.set_xlabel(opts.x_label if opts.x_label is not None else xcolumn)

plot.save('overlay-plot_process%s'%opts.tag, fig, directory=opts.output_dir, figtypes=opts.figtype, dpi=opts.dpi, verbose=opts.verbose)
plot.plt.close(fig)
