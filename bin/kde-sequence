#!/usr/bin/env python

"""a plotting script that makes a sequence of KDEs to show how constraints change for a 1D distribution with more events or different weights
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os
import numpy as np

from argparse import ArgumentParser

### non-standard libraries
from universality import utils
from universality import stats
from universality import plot

#-------------------------------------------------

parser = ArgumentParser(description=__doc__)

parser.add_argument('column', type=str)
parser.add_argument('--multiplier', type=float, default=1.)

parser.add_argument('--logcolumn', default=False, action='store_true')
parser.add_argument('--column-label', default=None, type=str)
parser.add_argument('--column-range', nargs=2, type=float)
parser.add_argument('--column-bandwidth', default=utils.DEFAULT_BANDWIDTH, type=float)
parser.add_argument('--column-truth', default=None, type=float)

parser.add_argument('--level', default=[], action='append', type=float,
    help='confidence levels for highest-probability-density credible regions')

parser.add_argument('-s', '--samples', nargs=2, type=str, default=[], action='append')
parser.add_argument('-m', '--max-num-samples', nargs=2, default=[], type=str, action='append')
parser.add_argument('--weight-column', nargs=2, type=str, default=[], action='append')
parser.add_argument('--weight-column-is-log', nargs=2, type=str, default=[], action='append')

parser.add_argument('--color', nargs=2, action='append', default=[], type=str)
parser.add_argument('--truth-color', default=plot.DEFAULT_TRUTH_COLOR, type=str)

parser.add_argument('--prune', default=False, action='store_true')
parser.add_argument('--reflect', default=False, action='store_true')

parser.add_argument('-n', '--num-points', default=plot.DEFAULT_NUM_POINTS, type=int)
parser.add_argument('--num-proc', default=utils.DEFAULT_NUM_PROC, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

parser.add_argument('--grid', default=False, action='store_true')
parser.add_argument('-o', '--output-dir', default='.', type=str)
parser.add_argument('-t', '--tag', default='', type=str)
parser.add_argument('--figtype', default=[], type=str, action='append')
parser.add_argument('--dpi', default=plot.DEFAULT_DPI, type=float)

args = parser.parse_args()

### finish parsing
if not os.path.exists(args.output_dir):
    os.makedirs(args.output_dir)

if args.tag:
    args.tag = "_"+args.tag

if not args.figtype:
    args.figtype = plot.DEFAULT_FIGTYPES

if args.column_label is None:
    args.column_label = label

names = [label for label, path in args.samples]

max_num_samples = dict((label, np.infty) for label in names)
for label, num in args.max_num_samples:
    assert label in names, 'specifying --max-num-sample for unknown sample set: '+label
    max_num_samples[label] = int(num)

weight_columns = dict((label, ([], [])) for label in names)
for label, column in args.weight_column:
    assert label in names, 'specifying --weight-column for unknown sample set: '+label
    weight_columns[label][0].append(column)
for label, column in args.weight_column_is_log:
    assert label in names, 'specifying --weight-column-is-log for unknown sample set: '+label
    weight_columns[label][1].append(column)

logcolumns = [args.column] if args.logcolumn else []

colors = dict((label, plot.DEFAULT_COLOR1) for label in names)
for label, color in args.color:
    assert label in names, 'specifying --color for uknown sample set: '+label
    colors[label] = color

#-------------------------------------------------

fig = plot.figure()
ax = fig.gca()

variance = args.column_bandwidth**2
ones = np.ones(args.num_points, dtype=float)

for ind, (label, path) in enumerate(args.samples):
    if args.verbose:
        print('reading in samples for %s from: %s'%(label, path))
    data, _ = utils.load(path, [args.column], logcolumns=logcolumns, max_num_samples=max_num_samples[label])

    if weight_columns[label][0]:
        if args.verbose:
            print('reading in non-trivial weights from: '+path)
        weights = utils.load_weights(path, weight_columns[label][0], logweightcolumns=weight_columns[label][1], max_num_samples=max_num_samples[label])

    else:
        N = len(data)
        weights = np.ones(N, dtype='float')/N

    if args.column_range:
        m, M = args.column_range
    else:
        m, M = np.min(data), np.max(data)

    if args.prune:### throw away data that's outside the bounds
        data, weights = utils.prune(data, [(m, M)], weights=weights)

    if args.reflect:
        data, weights = utils.reflect(data, [(m, M)], weights=weights)

    samples = np.linspace(m, M, args.num_points)
    kde = utils.logkde(
        samples,
        data,
        variance,
        weights=weights,
        num_proc=args.num_proc,
    )
    kde = np.exp(kde - np.max(kde))
    kde /= 2. ### normalize to be half the spacing between things

    ax.plot(ind*ones+kde, args.multiplier*samples, color=colors[label]) ### make a violin plot
    ax.plot(ind*ones-kde, args.multiplier*samples, color=colors[label])

    if args.level:
        for vals in stats.samples2crbounds(data[:,0], args.level, weights=weights):
            for val in vals:
                ax.plot([ind-0.5, ind+0.5], [val]*2, color=colors[label], linestyle='dashed')

### decorate

ax.set_xticks(range(len(args.samples)))
ax.set_xticklabels(names)
ax.set_ylabel(args.column_label)

xlim = (-0.75, len(args.samples)-0.25)
if args.column_truth is not None:
    ax.plot(xlim, [args.column_truth]*2, color=args.truth_color)
ax.set_xlim(xlim)

if args.grid:
    ax.grid(True, which='both')


### save
plot.save('kde-sequence%s'%args.tag, fig, figtypes=args.figtype, directory=args.output_dir, verbose=args.verbose, dpi=args.dpi)
plot.close(fig)
